using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using WizardsChess.Chess;
using WizardsChess.Movement;
using WizardsChess.Movement.Drv;
using WizardsChess.VoiceControl;
using WizardsChess.VoiceControl.Commands;
using WizardsChess.VoiceControl.Events;

namespace WizardsChess
{
	enum GameState
	{
		Ready,
		Playing,
		AwaitingReset,
		Complete
	}

	class GameManager
	{
		private GameManager(ICommandInterpreter commandInterpreter, ChessLogic logic, IMoveManager movementManager)
		{
			commandInterpreter.CommandReceived += CommandReceived;

			cmdInterpreter = commandInterpreter;
			chessLogic = logic;
			moveManager = movementManager;
			gameState = GameState.Ready;
		}

		public static async Task<GameManager> CreateAsync()
		{
			var commandInterpreterConstructor = CommandInterpreter.CreateAsync();

			ChessLogic logic = new ChessLogic();

			var stepCountPinX = new GpioPinWrapper(5, Windows.Devices.Gpio.GpioPinDriveMode.InputPullUp);
			var stepClearPinX = new GpioPinWrapper(13, Windows.Devices.Gpio.GpioPinDriveMode.Output, Windows.Devices.Gpio.GpioPinValue.Low);
			var motorInformationX = new MotorInformation(Axis.X, stepCountPinX);
			var motorDriverX = new MotorDrv(20, 21, motorInformationX);
			var motorLocatorX = new MotorLocator(stepClearPinX, motorDriverX.Information);
			var positionSignalerX = new PositionSignaler(motorLocatorX);
			var motorMoverX = new MotorMover(50, positionSignalerX, motorLocatorX, motorDriverX);

			var stepCountPinY = new GpioPinWrapper(6, Windows.Devices.Gpio.GpioPinDriveMode.InputPullUp);
			var stepClearPinY = new GpioPinWrapper(19, Windows.Devices.Gpio.GpioPinDriveMode.Output, Windows.Devices.Gpio.GpioPinValue.Low);
			var motorInformationY = new MotorInformation(Axis.Y, stepCountPinY);
			var motorDriverY = new MotorDrv(24, 23, motorInformationY);
			var motorLocatorY = new MotorLocator(stepClearPinY, motorDriverY.Information);
			var positionSignalerY = new PositionSignaler(motorLocatorY);
			var motorMoverY = new MotorMover(50, positionSignalerY, motorLocatorY, motorDriverY);

			var topInterrupterX = new PhotoInterrupter(17, 1, 150);
			var bottomInterrupterX = new PhotoInterrupter(27, -1, -150);
			var motorCalibratorX = new MotorCalibrator(-23, 23, motorMoverX, motorInformationX, topInterrupterX, bottomInterrupterX);

			var topInterrupterY = new PhotoInterrupter(25, 1, 150);
			var bottomInterrupterY = new PhotoInterrupter(22, -1, -150);
			var motorCalibratorY = new MotorCalibrator(-17, 17, motorMoverY, motorInformationY, topInterrupterY, bottomInterrupterY);

			var preciseMoverX = new PreciseMotorMover(motorMoverX, motorCalibratorX);
			var gridMoverX = new GridMotorMover(preciseMoverX);

			var preciseMoverY = new PreciseMotorMover(motorMoverY, motorCalibratorY);
			var gridMoverY = new GridMotorMover(preciseMoverY);

			var magnetDriver = new MagnetDrv(26);

			var movePerformer = new MovePerformer(gridMoverX, gridMoverY, magnetDriver);
			var motorCalibrationTask = movePerformer.CalibrateAsync();
			var movePlanner = new MovePlanner(logic.Board);
			var moveManager = new MoveManager(movePlanner, movePerformer);

			GameManager manager = new GameManager(await commandInterpreterConstructor, logic, moveManager);

			await motorCalibrationTask;
#if DEBUG
				manager.DebugMovePerformer = movePerformer;
#endif
			return manager;
		}

		public async Task<GameState> PlayGameAsync()
		{
			gameState = GameState.Playing;
			await cmdInterpreter.StartAsync();

			while (gameState == GameState.Playing)
			{
				await Task.Delay(500);
			}

			return gameState;
		}

		public Task ResetAsync()
		{
			throw new NotImplementedException("Not yet implemented");
		}

		public Task CongratulateWinnerAsync()
		{
			throw new NotImplementedException("Congratulate winner not yet implemented");
		}

		private async void CommandReceived(Object sender, CommandEventArgs args)
		{
			System.Diagnostics.Debug.WriteLine($"Received command of type {args.Command.Type}.");
			//TODO: fill in comments below
			switch (args.Command.Type)
			{
				case CommandType.Move:
					var moveCmd = args.Command as MoveCommand;
					currentMoveCommand = moveCmd;
					await performMoveIfValidAsync(moveCmd);
					break;
				case CommandType.Castle:
					await performCastleIfValid();
					break;
				case CommandType.ConfirmPiece:
					var pieceConfirmation = args.Command as ConfirmPieceCommand;
					if (currentMoveCommand == null)
					{
						System.Diagnostics.Debug.WriteLine($"Received piece confirmation command when currentMoveCommand was null");
					}
					currentMoveCommand.Position = pieceConfirmation.Position;
					await performMoveIfValidAsync(currentMoveCommand);
					break;
				case CommandType.Undo:
					//no output when undo not possible, basically ignore it
					await performUndoIfPossible();
					break;
				//case yes
				//case no
				//case cancel?
				//case MotorMove?
				//case Magnet?
				default:
					//debug writing done above
					break;
			}
			

#if DEBUG
			if (args.Command.Type.GetFamily() == CommandFamily.Debug)
			{
				HandleDebugCommand(args.Command);
				return;
			}
#endif
		}

		private async Task performMoveIfValidAsync(MoveCommand moveCmd)
		{
			if (!moveCmd.Position.HasValue)	//checks command format
			{
				var possibleStartPositions = chessLogic.FindPotentialPiecesForMove(moveCmd.Piece.Value, moveCmd.Destination);
				if (possibleStartPositions.Count == 0)
				{
					System.Diagnostics.Debug.WriteLine($"Could not find a possible starting piece of type {moveCmd.Piece.Value} going to {moveCmd.Destination}");
					//TODO: output saying no valid moves fit that description
					return;
				}
				else if (possibleStartPositions.Count == 1)
				{
					moveCmd.Position = possibleStartPositions.First();
				}
				else
				{
					await cmdInterpreter.ConfirmPieceSelectionAsync(moveCmd.Piece.Value, possibleStartPositions.ToList());
					return;
				}
			}
			else
			{
				if (!chessLogic.IsMoveValid((Position)moveCmd.Position, moveCmd.Destination))
				{
					System.Diagnostics.Debug.WriteLine($"Specified move not valid.");
					//TODO: output saying no valid moves fit that description
					return;
				}
			}
			if (chessLogic.DoesMoveCapture((Position)moveCmd.Position, moveCmd.Destination))	//piece captured
			{
				await moveManager.MoveAsync(new Point2D((Position)moveCmd.Position), new Point2D(moveCmd.Destination), new Point2D(chessLogic.CaptureLocation((Position)moveCmd.Position, moveCmd.Destination)));
			}
			else
			{
				await moveManager.MoveAsync(new Point2D((Position)moveCmd.Position), new Point2D(moveCmd.Destination));
			}
			chessLogic.MovePiece((Position)moveCmd.Position, moveCmd.Destination);
		}

		private async Task performCastleIfValid()
		{
			var validRookLocations = chessLogic.validRookLocationsForCastling();
			if (validRookLocations.Count == 0)
			{
				System.Diagnostics.Debug.WriteLine($"No valid castles");
				//TODO: output saying no valid moves fit that description
				return;
			}
			else if (validRookLocations.Count == 1)
			{
				await moveManager.CastleAsync(validRookLocations[0], chessLogic.Board.GetKingCol());
				chessLogic.Castle(validRookLocations[0]);
			}
			else	// validRookLocations.Count == 2
			{
				//await cmdInterpreter.ConfirmPieceSelectionAsync(moveCmd.Piece.Value, validRookLocations);
				//TODO: figure out how to make this similar
				return;

			}
		}

		private async Task performUndoIfPossible()
		{
			await moveManager.UndoMoveAsync();
			chessLogic.UndoMove();
		}

		private ICommandInterpreter cmdInterpreter;
		private ChessLogic chessLogic;
		private IMoveManager moveManager;
		private GameState gameState;
		private MoveCommand currentMoveCommand;

#if DEBUG
		public IMovePerformer DebugMovePerformer;

		private void HandleDebugCommand(ICommand command)
		{
			switch (command.Type)
			{
				case CommandType.MotorMove:
					var mtrMvCmd = command as MotorMoveCommand;
					DebugMovePerformer.MoveMotorAsync(mtrMvCmd.Axis, mtrMvCmd.Steps);
					break;
				case CommandType.Magnet:
					var magnetCmd = command as MagnetCommand;
					DebugMovePerformer.EnableMagnet(magnetCmd.EnableMagnet);
					break;
				default:
					break;
			}
		}
#endif
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.Devices.Gpio;
using WizardsChess.Movement.Drv.Events;

namespace WizardsChess.Movement.Drv
{
	class GpioPinWrapper : IGpioPin, IDisposable
	{
		public event GpioValueChangedEventHandler ValueChanged;
		public int PinNum { get; }

		public GpioPinWrapper(int pinNum, GpioPinDriveMode mode, GpioPinValue value=GpioPinValue.Low)
		{
			var gpio = GpioController.GetDefault();
			this.PinNum = pinNum;
			pin = gpio.OpenPin(pinNum);
			pin.Write(value);
			pin.SetDriveMode(mode);

			pin.ValueChanged += realPinValueChanged;
		}

		public GpioValue Read()
		{
			return convertWindowsValueToCustomValue(pin.Read());
		}

		public void Write(GpioValue val)
		{
			pin.Write(convertCustomValueToWindowsValue(val));
		}

		private void realPinValueChanged(GpioPin sender, GpioPinValueChangedEventArgs e)
		{
			GpioValueChangedEventArgs edgeArgs = new GpioValueChangedEventArgs(GpioEdge.FallingEdge);
			if (e.Edge == GpioPinEdge.RisingEdge)
			{
				edgeArgs = new GpioValueChangedEventArgs(GpioEdge.RisingEdge);
			}
			ValueChanged?.Invoke(this, edgeArgs);
		}

		private GpioPin pin;

		private GpioValue convertWindowsValueToCustomValue(GpioPinValue windowsVal)
		{
			if (windowsVal == GpioPinValue.High)
			{
				return GpioValue.High;
			}
			else
			{
				return GpioValue.Low;
			}
		}

		private GpioPinValue convertCustomValueToWindowsValue(GpioValue customVal)
		{
			if (customVal == GpioValue.High)
			{
				return GpioPinValue.High;
			}
			else
			{
				return GpioPinValue.Low;
			}
		}

		#region IDisposable Support
		private bool disposedValue = false; // To detect redundant calls

		protected virtual void Dispose(bool disposing)
		{
			if (!disposedValue)
			{
				if (disposing)
				{
					pin.ValueChanged -= realPinValueChanged;
				}

				disposedValue = true;
			}
		}

		// This code added to correctly implement the disposable pattern.
		public void Dispose()
		{
			// Do not change this code. Put cleanup code in Dispose(bool disposing) above.
			Dispose(true);
		}
		#endregion
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.Devices.Gpio;

namespace WizardsChess.Movement.Drv
{
	class MagnetDrv : IMagnetDrv
	{
		public MagnetDrv(int pinNum)
		{
			var gpio = GpioController.GetDefault();
			pin = gpio.OpenPin(pinNum);
			pin.Write(GpioPinValue.Low);
			pin.SetDriveMode(GpioPinDriveMode.Output);
			pin.Write(GpioPinValue.Low);
		}

		private GpioPin pin;

		public bool IsOn
		{
			get
			{
				return pin.Read() == GpioPinValue.High;
			}
		}

		public void TurnOn()
		{
			pin.Write(GpioPinValue.High);
		}

		public void TurnOff()
		{
			pin.Write(GpioPinValue.Low);
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.Devices.Gpio;
using WizardsChess.Movement;

namespace WizardsChess.Movement.Drv
{
	class MotorDrv : IMotorDrv
	{
		public MotorDrv(int forwardGpio, int backwardGpio, MotorInformation info)
		{
			var gpio = GpioController.GetDefault();
			forwardPin = gpio.OpenPin(forwardGpio);
			backwardPin = gpio.OpenPin(backwardGpio);
			forwardPin.Write(GpioPinValue.Low);
			backwardPin.Write(GpioPinValue.Low);
			forwardPin.SetDriveMode(GpioPinDriveMode.Output);
			backwardPin.SetDriveMode(GpioPinDriveMode.Output);

			direction = MoveDirection.Stopped;
			previousDirection = direction;

			information = info;
		}

		public MoveDirection Direction
		{
			get
			{
				lock (lockObject)
				{
					return direction;
				}
			}

			set
			{
				if (direction == value)
				{
					return;
				}
				lock (lockObject)
				{
					previousDirection = direction;
					direction = value;
				}
				updatePins();
			}
		}

		public MoveDirection PreviousDirection
		{
			get
			{
				lock (lockObject)
				{
					return previousDirection;
				}
			}
		}

		public IMotorInformation Information
		{
			get { return information; }
		}

		public MoveDirection GetLatestActiveMoveDirection()
		{
			lock(lockObject)
			{
				if (direction != MoveDirection.Stopped)
				{
					return direction;
				}
				else
				{
					return previousDirection;
				}
			}
		}

		private object lockObject = new object();
		private MoveDirection direction;
		private MoveDirection previousDirection;
		private GpioPin forwardPin;
		private GpioPin backwardPin;
		private MotorInformation information;

		private void updatePins()
		{
			switch (direction)
			{
				case MoveDirection.Forward:
					System.Diagnostics.Debug.WriteLine($"Moving the {information.Axis} motor forwards");
					information.SetDirection(direction);
					backwardPin.Write(GpioPinValue.Low);
					forwardPin.Write(GpioPinValue.High);
					break;
				case MoveDirection.Backward:
					System.Diagnostics.Debug.WriteLine($"Moving the {information.Axis} motor backwards");
					information.SetDirection(direction);
					forwardPin.Write(GpioPinValue.Low);
					backwardPin.Write(GpioPinValue.High);
					break;
				case MoveDirection.Stopped:
				default:
					System.Diagnostics.Debug.WriteLine($"Stopping the {information.Axis} motor");
					forwardPin.Write(GpioPinValue.Low);
					backwardPin.Write(GpioPinValue.Low);
					break;
			}
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.Devices.Gpio;
using WizardsChess.Movement.Drv.Events;

namespace WizardsChess.Movement.Drv
{
	class PhotoInterrupter : GpioPinWrapper, IPhotoInterrupter
	{
		public int GridPosition { get; }

		public int StepPosition { get; set; }

		public PhotoInterrupter(int pinNum, int gridPosition, int estStepPosition) : base(pinNum, GpioPinDriveMode.InputPullUp)
		{
			GridPosition = gridPosition;
			StepPosition = estStepPosition;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net.Http;
using Windows.ApplicationModel.Background;
using System.Threading.Tasks;

// The Background Application template is documented at http://go.microsoft.com/fwlink/?LinkID=533884&clcid=0x409

namespace WizardsChess
{
	public sealed class StartupTask : IBackgroundTask
	{
		public async void Run(IBackgroundTaskInstance taskInstance)
		{
			//
			// Create the deferral by requesting it from the task instance.
			//
			BackgroundTaskDeferral deferral = taskInstance.GetDeferral();

			GameManager gameManager = await GameManager.CreateAsync();

			// Loop continuously
			while (true)
			{
				var state = await gameManager.PlayGameAsync();
				switch (state)
				{
					case GameState.Ready:
						break;
					case GameState.Complete:
						await gameManager.CongratulateWinnerAsync();
						await gameManager.ResetAsync();
						break;
					case GameState.AwaitingReset:
					default:
						await gameManager.ResetAsync();
						break;
				}
			}

			//
			// Once the asynchronous method(s) are done, close the deferral.
			//
			//deferral.Complete();
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.Media.SpeechRecognition;
using WizardsChess.Chess;
using WizardsChess.VoiceControl.Commands;
using WizardsChess.VoiceControl.Events;

namespace WizardsChess.VoiceControl
{
	enum ListeningState
	{
		Move,
		Hypothesis,
		PieceConfirmation
	}

	/// <summary>
	/// Receives commands from the CommandListener, validates commands using the Communicator, and then exposes confirmed, valid commands.
	/// </summary>
	class CommandInterpreter : ICommandInterpreter
	{
		#region Events
		public event CommandEventHandler CommandReceived;

		private void onCommandReceived(CommandEventArgs e)
		{
			CommandReceived?.Invoke(this, e);
		}
		#endregion

		#region Construction
		private CommandInterpreter(SpeechRecognizer speechRecognizer, ICommunicator communicator)
		{
			isStarted = false;
			commandHypothesis = null;
			listeningState = ListeningState.Move;

			recognizer = speechRecognizer;

			listener = new CommandListener(speechRecognizer);

			listener.ReceivedCommand += receivedCommand;
			listener.ReceivedCommandHypothesis += receivedCommandHypothesis;

			this.communicator = communicator;
		}

		public static async Task<CommandInterpreter> CreateAsync()
		{
			var speechRecognizer = new SpeechRecognizer();

			var interpreter = new CommandInterpreter(speechRecognizer, new Communicator());

			var grammarCompilationResult = await interpreter.setupGrammarConstraintsAsync();
			if (grammarCompilationResult.Status != SpeechRecognitionResultStatus.Success)
			{
				throw new FormatException($"Could not compile grammar constraints. Received error {grammarCompilationResult.Status}");
			}

			return interpreter;
		}
		#endregion

		public async Task ConfirmPieceSelectionAsync(PieceType pieceType, IReadOnlyList<Position> possiblePositions)
		{
			StringBuilder confirmPieceSpeech = new StringBuilder();
			confirmPieceSpeech.Append($"Do you mean the {pieceType} at position ");

			int i = 0;
			for (i = 0; i < (possiblePositions.Count - 1); i++)
			{
				confirmPieceSpeech.Append($"{possiblePositions[i]}, ");
			}
			confirmPieceSpeech.Append($"or {possiblePositions[i]}?");

			await speakAsync(confirmPieceSpeech.ToString());

			possiblePieceType = pieceType;
			possiblePiecePositions = possiblePositions;
			await changeStateAsync(ListeningState.PieceConfirmation);
		}

		public async Task StartAsync()
		{
			if (isStarted)
			{
				return;
			}

			await changeStateAsync(ListeningState.Move);
			await listener.StartListeningAsync();
			isStarted = true;
		}

		#region Private Members
		private bool isStarted;
		private ListeningState listeningState;
		private ListeningState preHypothesisListeningState;
		private SpeechRecognizer recognizer;
		private ICommandListener listener;
		private ICommunicator communicator;
		private CommandHypothesisEventArgs commandHypothesis;
		private PieceType possiblePieceType;
		private IReadOnlyList<Position> possiblePiecePositions;
		#endregion

		#region Private Methods
		private async Task<SpeechRecognitionCompilationResult> setupGrammarConstraintsAsync()
		{
			var grammarConstraints = await SpeechConstraints.GetConstraintsAsync();
			foreach (var constraint in grammarConstraints)
			{
				if (constraint != null)
				{
					recognizer.Constraints.Add(constraint);
				}
				else
				{
					System.Diagnostics.Debug.WriteLine("Received a null grammar constraint");
				}
			}
			return await recognizer.CompileConstraintsAsync().AsTask();
		}

		private async Task changeStateAsync(ListeningState state)
		{
			if (listeningState != state)
			{
				System.Diagnostics.Debug.WriteLine($"Changing CommandInterpreter listening state to {state}");

				if (state == ListeningState.Hypothesis)
				{
					preHypothesisListeningState = listeningState;
				}

				listeningState = state;

				await listener.StopListeningAsync();
				
				switch (state)
				{
					case ListeningState.Move:
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.MoveCommands, true);
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.PieceConfirmation, false);
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.YesNoCommands, false);
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.CancelCommand, false);
						break;
					case ListeningState.PieceConfirmation:
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.PieceConfirmation, true);
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.MoveCommands, false);
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.YesNoCommands, false);
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.CancelCommand, true);
						break;
					case ListeningState.Hypothesis:
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.YesNoCommands, true);
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.MoveCommands, false);
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.PieceConfirmation, false);
						SpeechConstraints.EnableGrammar(recognizer.Constraints, GrammarMode.CancelCommand, true);
						break;
					default:
						throw new Exception("Tried to change CommandInterpreter state to an unknown listening state");
				}

				await listener.StartListeningAsync();
			}
		}

		private async void receivedCommand(Object sender, CommandEventArgs e)
		{
			if (isCommandFamilyValid(e.Command.Type.GetFamily()))
			{
				await handleCommandAsync(e.Command);
			}
			else
			{
				System.Diagnostics.Debug.WriteLine($"CommandInterpreter received invalid command of type {e.Command.Type}");
				// TODO: This demonstrates a major internal error. Handle it.
			}
		}

		private async void receivedCommandHypothesis(Object sender, CommandHypothesisEventArgs e)
		{
			if (listeningState == ListeningState.Hypothesis)
			{
				await changeStateAsync(preHypothesisListeningState);
				await handleRejectedHypothesisAsync();
				return;
			}

			//await listener.StopListeningAsync();
			commandHypothesis = e;
			await changeStateAsync(ListeningState.Hypothesis);
			await speakAsync($"Did you say: {e.CommandText}");
			//await listener.StartListeningAsync();
		}

		private bool isCommandFamilyValid(CommandFamily family)
		{
#if DEBUG
			if (family == CommandFamily.Debug)
			{
				return true;
			}
#endif
			switch (listeningState)
			{
				case ListeningState.Hypothesis:
					return family == CommandFamily.YesNo || family == CommandFamily.Other;
				case ListeningState.PieceConfirmation:
					return family == CommandFamily.PieceConfirmation || family == CommandFamily.Other;
				case ListeningState.Move:
				default:
					return family == CommandFamily.Move;
			}
		}

		private async Task handleCommandAsync(ICommand command)
		{
#if DEBUG
			if (command.Type.GetFamily() == CommandFamily.Debug)
			{
				onCommandReceived(new CommandEventArgs(command));
			}
#endif
			switch (listeningState)
			{
				case ListeningState.Hypothesis:
					await handleHypothesisConfirmationResponseAsync(command);
					break;
				case ListeningState.PieceConfirmation:
					await handleConfirmPieceCommandAsync(command);
					break;
				case ListeningState.Move:
				default:
					onCommandReceived(new CommandEventArgs(command));
					break;
			}
		}

		private async Task handleHypothesisConfirmationResponseAsync(ICommand command)
		{
			await changeStateAsync(preHypothesisListeningState);
			if (isHypothesisValid(command))
			{
				// The last command was understood correctly, handle it as a regular command
				receivedCommand(this, commandHypothesis);
			}
			else
			{
				await handleRejectedHypothesisAsync();
			}
		}

		private async Task handleRejectedHypothesisAsync()
		{
			switch (listeningState)
			{
				case ListeningState.Hypothesis:
					System.Diagnostics.Debug.WriteLine("CommandInterpreter got stuck in the Hypothesis state afer rejecting a hypothesis");
					break;
				case ListeningState.PieceConfirmation:
					await ConfirmPieceSelectionAsync(possiblePieceType, possiblePiecePositions);
					break;
				case ListeningState.Move:
				default:
					await speakAsync("Ok. Please repeat your previous command.");
					break;
			}
		}

		private bool isHypothesisValid(ICommand command)
		{
			var family = command.Type.GetFamily();
			if (family == CommandFamily.YesNo)
			{
				return command.Type == CommandType.Yes;
			}
			return false;
		}

		private async Task handleConfirmPieceCommandAsync(ICommand command)
		{
			if (isValidPieceCommand(command as ConfirmPieceCommand))
			{
				onCommandReceived(new CommandEventArgs(command));
			}
			else if (command.Type != CommandType.Cancel)
			{
				// Try piece confirmation again if their answer just didn't make sense
				await speakAsync("That position was not valid.");
				await ConfirmPieceSelectionAsync(possiblePieceType, possiblePiecePositions);
				return;
			}
			else
			{
				// If they cancel, return to move command state
				await speakAsync("Ok. Please repeat your move command.");
			}
			await changeStateAsync(ListeningState.Move);
		}

		private bool isValidPieceCommand(ConfirmPieceCommand command)
		{
			// Check the start position is actually one we asked for.
			foreach (var position in possiblePiecePositions)
			{
				if (position == command.Position)
				{
					return true;
				}
			}

			return false;
		}

		private async Task speakAsync(string text)
		{
			await listener.StopListeningAsync();
			await communicator.SpeakAsync(text);
			await listener.StartListeningAsync();
		}
		#endregion
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.Media.SpeechRecognition;
using WizardsChess.Chess;
using WizardsChess.VoiceControl.Commands;
using WizardsChess.VoiceControl.Events;

namespace WizardsChess.VoiceControl
{
	/// <summary>
	/// CommandListener converts commands from voice recognition to valid ICommands for an ICommandInterpreter.
	/// </summary>
	class CommandListener : ICommandListener
	{
		#region Public Events
		public event CommandEventHandler ReceivedCommand;
		public event CommandHypothesisEventHandler ReceivedCommandHypothesis;

		private void onCommandRecognized(CommandEventArgs e)
		{
			ReceivedCommand?.Invoke(this, e);
		}

		private void onCommandHypothesized(CommandHypothesisEventArgs e)
		{
			ReceivedCommandHypothesis?.Invoke(this, e);
		}
		#endregion

		public bool IsListening { get { return isListening; } }

		public CommandListener(SpeechRecognizer speechRecognizer)
		{
			isListening = false;
			recognizer = speechRecognizer;
			continuousSession = recognizer.ContinuousRecognitionSession;
			continuousSession.AutoStopSilenceTimeout = TimeSpan.FromMinutes(5);
			continuousSession.ResultGenerated += respondToSpeechRecognition;
		}

		public async Task StartListeningAsync()
		{
			if (!isListening)
			{
				try
				{
					await continuousSession.StartAsync().AsTask();
				}
				catch (Exception e)
				{
					System.Diagnostics.Debug.WriteLine($"Could not start listening. Threw exception {e}");
				}
				isListening = true;
			}
		}

		public async Task StopListeningAsync()
		{
			if (isListening)
			{
				try
				{
					await continuousSession.StopAsync();
				}
				catch (Exception e)
				{
					System.Diagnostics.Debug.WriteLine($"Could not stop listening. Threw exception {e}");
				}
				isListening = false;
			}
		}

		#region Private Members
		private bool isListening;
		private SpeechRecognizer recognizer;
		private SpeechContinuousRecognitionSession continuousSession;
		#endregion

		#region Private Methods
		private void respondToSpeechRecognition(
			SpeechContinuousRecognitionSession sender,
			SpeechContinuousRecognitionResultGeneratedEventArgs args)
		{
			if (args.Result.Status == SpeechRecognitionResultStatus.Success)
			{
				System.Diagnostics.Debug.WriteLine($"Recognized speech: {args.Result.Text}");
				System.Diagnostics.Debug.WriteLine($"Recognition confidence: {args.Result.Confidence}");
				if (args.Result.Confidence == SpeechRecognitionConfidence.Rejected)
				{
					return;
				}
				else if (args.Result.Confidence == SpeechRecognitionConfidence.Low)
				{
					// Throw the response away
					//onCommandHypothesized(new CommandHypothesisEventArgs(convertSpeechToCommand(args.Result), args.Result.Text));
				}
				else
				{
					var command = convertSpeechToCommand(args.Result);
					if (command.Type == CommandType.Move)
					{
						var moveCommand = command as MoveCommand;
						if (moveCommand.Position.HasValue && !moveCommand.PositionUsedNatoAlphabet)
						{
							if (isPositionAmbiguous(moveCommand.Position.Value, args.Result.Confidence))
							{
								onCommandHypothesized(new CommandHypothesisEventArgs(command, args.Result.Text));
								return;
							}
						}
						if (!moveCommand.DestinationUsedNatoAlphabet)
						{
							if (isPositionAmbiguous(moveCommand.Destination, args.Result.Confidence))
							{
								onCommandHypothesized(new CommandHypothesisEventArgs(command, args.Result.Text));
								return;
							}
						}
					}
					else if (command.Type == CommandType.ConfirmPiece)
					{
						var confirmPieceCommand = command as ConfirmPieceCommand;
						if (!confirmPieceCommand.PositionUsedNatoAlphabet)
						{
							if (isPositionAmbiguous(confirmPieceCommand.Position, args.Result.Confidence))
							{
								onCommandHypothesized(new CommandHypothesisEventArgs(command, args.Result.Text));
								return;
							}
						}
					}
					onCommandRecognized(new CommandEventArgs(convertSpeechToCommand(args.Result)));
				}
			}
			else
			{
				System.Diagnostics.Debug.WriteLine($"Received continuous speech result of {args.Result.Status}");
			}
		}

		private ICommand convertSpeechToCommand(SpeechRecognitionResult speech)
		{
			var cmdType = CommandTypeMethods.Parse(speech.SemanticInterpretation.Properties);
			switch (cmdType)
			{
				case CommandType.Move:
					return new MoveCommand(speech.SemanticInterpretation.Properties);
				case CommandType.ConfirmPiece:
					return new ConfirmPieceCommand(speech.SemanticInterpretation.Properties);
				case CommandType.MotorMove:
					return new MotorMoveCommand(speech.SemanticInterpretation.Properties);
				case CommandType.Magnet:
					return new MagnetCommand(speech.SemanticInterpretation.Properties);
				default:
					return new Command(speech.SemanticInterpretation.Properties);
			}
		}

		private bool isPositionAmbiguous(Position p, SpeechRecognitionConfidence confidence)
		{
			if (confidence == SpeechRecognitionConfidence.High)
			{
				return false;
			}

			return p.ColumnLetter == ColumnLetter.B
				|| p.ColumnLetter == ColumnLetter.C
				|| p.ColumnLetter == ColumnLetter.D
				|| p.ColumnLetter == ColumnLetter.E
				|| p.ColumnLetter == ColumnLetter.G;
		}
		#endregion
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.Media.Playback;
using Windows.Media.SpeechSynthesis;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;

namespace WizardsChess.VoiceControl
{
	class Communicator : ICommunicator
	{
		public Communicator()
		{
			speechSynth = new SpeechSynthesizer();
			try
			{
				audioOut = Windows.Media.Playback.BackgroundMediaPlayer.Current;
			}
			catch (Exception e)
			{
				System.Diagnostics.Debug.WriteLine(e);
			}
			audioOut.PlaybackSession.PlaybackStateChanged += playbackStateChanged;
		}

		public async Task SpeakAsync(string text)
		{
			if (audioOut.PlaybackSession.PlaybackState == MediaPlaybackState.Playing)
			{
				audioOut.Pause();
			}
			var voiceStream = await speechSynth.SynthesizeTextToStreamAsync(text);
			if (voiceStream == null)
			{
				System.Diagnostics.Debug.WriteLine($"Could not synthesize voice stream from text: {text}.");
			}

			audioOut.Source = Windows.Media.Core.MediaSource.CreateFromStream(voiceStream, voiceStream.ContentType);
			audioOut.Play();

			while (audioOut.PlaybackSession.PlaybackState != MediaPlaybackState.Paused)
			{
				await Task.Delay(75);
			}
		}

		private void playbackStateChanged(MediaPlaybackSession sender, object e)
		{
			System.Diagnostics.Debug.WriteLine($"Received playback state changed event: {e?.ToString()} in state: {sender.PlaybackState}");
		}

		private SpeechSynthesizer speechSynth;
		private MediaPlayer audioOut;
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.Media.SpeechRecognition;
using Windows.Storage;

namespace WizardsChess.VoiceControl
{
	enum GrammarMode
	{
		MoveCommands,
		YesNoCommands,
		PieceConfirmation,
		CancelCommand
	}

	static class SpeechConstraints
	{
		public static async Task<IList<ISpeechRecognitionConstraint>> GetConstraintsAsync()
		{
			var grammarList = new List<ISpeechRecognitionConstraint>();

			var commandsFileTask = StorageFile.GetFileFromApplicationUriAsync(new Uri("ms-appx:///VoiceControl/MoveCommands.grxml")).AsTask();
			var yesNoFileTask = StorageFile.GetFileFromApplicationUriAsync(new Uri("ms-appx:///VoiceControl/YesNoCommands.grxml")).AsTask();
			var pieceConfirmationTask = StorageFile.GetFileFromApplicationUriAsync(new Uri("ms-appx:///VoiceControl/PieceConfirmation.grxml")).AsTask();
			var cancelFileTask = StorageFile.GetFileFromApplicationUriAsync(new Uri("ms-appx:///VoiceControl/CancelCommand.grxml")).AsTask();

			await Task.WhenAll(commandsFileTask, yesNoFileTask, pieceConfirmationTask, cancelFileTask);

			var moveGrammar = new SpeechRecognitionGrammarFileConstraint(commandsFileTask.Result, moveCommandsGrammarTag);
			var yesNoGrammar = new SpeechRecognitionGrammarFileConstraint(yesNoFileTask.Result, yesNoCommandsGrammarTag);
			var pieceConfirmationGrammar = new SpeechRecognitionGrammarFileConstraint(pieceConfirmationTask.Result, pieceConfirmationGrammarTag);
			var cancelGrammar = new SpeechRecognitionGrammarFileConstraint(cancelFileTask.Result, cancelCommandGrammarTag);

			grammarList.Add(moveGrammar);
			grammarList.Add(yesNoGrammar);
			grammarList.Add(pieceConfirmationGrammar);
			grammarList.Add(cancelGrammar);

#if DEBUG
			var debugFile = await StorageFile.GetFileFromApplicationUriAsync(new Uri("ms-appx:///VoiceControl/DebugCommands.grxml")).AsTask();
			var debugGrammar = new SpeechRecognitionGrammarFileConstraint(debugFile, debugGrammarTag);
			grammarList.Add(debugGrammar);
#endif

			return grammarList;
		}

		public static void EnableGrammar(IList<ISpeechRecognitionConstraint> constraints, GrammarMode constraintTag, bool enable)
		{
			string tag;
			switch (constraintTag)
			{
				case GrammarMode.MoveCommands:
					tag = moveCommandsGrammarTag;
					break;
				case GrammarMode.YesNoCommands:
					tag = yesNoCommandsGrammarTag;
					break;
				case GrammarMode.PieceConfirmation:
					tag = pieceConfirmationGrammarTag;
					break;
				case GrammarMode.CancelCommand:
					tag = cancelCommandGrammarTag;
					break;
				default:
					throw new ArgumentException($"No such grammar constraint: {constraintTag}");
			}

			foreach (var constraint in constraints)
			{
				if (constraint.Tag == tag)
				{
					constraint.IsEnabled = enable;
					return;
				}
			}
		}

		private static readonly string moveCommandsGrammarTag = "moveCommands";
		private static readonly string yesNoCommandsGrammarTag = "yesNoCommands";
		private static readonly string pieceConfirmationGrammarTag = "pieceConfirmation";
		private static readonly string cancelCommandGrammarTag = "cancelCommand";
#if DEBUG
		private static readonly string debugGrammarTag = "debugCommand";
#endif
	}
}
﻿using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using WizardsChess.Chess;
using WizardsChess.Chess.Pieces;
using System.Collections.Generic;

namespace WizardsChessTest.Chess
{
	[TestClass]
	public class ChessLogicTest
	{
		[TestMethod]
		public void LogicMoveTesting()	//test against move that already exsists in chessboard
		{
			ChessLogic logic = new ChessLogic();
			ChessBoard board = new ChessBoard();
			Assert.AreEqual(logic.Board.ToString(), board.ToString());
			logic.MovePiece(new Position("C", "2"), new Position("C", "4"));
			board.MovePiece(new Position("C", "2"), new Position("C", "4"));
			Assert.AreEqual(logic.Board.ToString(), board.ToString());
			logic.MovePiece(new Position("B", "8"), new Position("C", "6"));
			board.MovePiece(new Position("B", "8"), new Position("C", "6"));
			Assert.AreEqual(logic.Board.ToString(), board.ToString());
			//logic.MovePiece(new Position("C", "4"), new Position("C", "4")); //threw appropriate exception
			//board.MovePiece(new Position("C", "4"), new Position("C", "4"));
			Assert.AreEqual(logic.Board.ToString(), board.ToString());
			//Assert.AreEqual(logic.Board.ToString(), "a");	//display board
		}
		[TestMethod]
		public void LogicPieceByLocationTesting()
		{
			ChessLogic logic = new ChessLogic();
			var pawnPlaces = logic.FindPotentialPiecesForMove(PieceType.Pawn, new Position("C","3"));
			Assert.AreEqual(pawnPlaces.Count, 1);
		}
		[TestMethod]
		public void LogicUndo()
		{
			ChessLogic logic = new ChessLogic();
			ChessLogic logic2 = new ChessLogic();
			ChessLogic logic3 = new ChessLogic();
			logic.MovePiece(new Position("C", "2"), new Position("C", "4"));

			logic2.MovePiece(new Position("C", "2"), new Position("C", "4"));
			logic2.MovePiece(new Position("B", "8"), new Position("C", "6"));
			logic2.MovePiece(new Position("C", "4"), new Position("C", "5"));
			logic2.UndoMove();

			logic3.MovePiece(new Position("C", "2"), new Position("C", "4"));
			logic3.MovePiece(new Position("B", "8"), new Position("C", "6"));
			Assert.AreEqual(logic2.Board.ToString(), logic3.Board.ToString());

			logic2.UndoMove();
			Assert.AreEqual(logic2.Board.ToString(), logic.Board.ToString());

			bool invalidMove = logic2.IsMoveValid(new Position("C", "4"), new Position("C", "5"));
			Assert.AreEqual(invalidMove, false);

			logic2.MovePiece(new Position("B", "8"), new Position("C", "6"));
			Assert.AreEqual(logic2.Board.ToString(), logic3.Board.ToString());
			logic2.MovePiece(new Position("C", "4"), new Position("C", "5"));
			logic2.UndoMove();
			Assert.AreEqual(logic2.Board.ToString(), logic3.Board.ToString());
			logic2.UndoMove();
			Assert.AreEqual(logic2.Board.ToString(), logic.Board.ToString());
		}
		[TestMethod]
		public void LogicCastleTesting()
		{
			ChessLogic logic = new ChessLogic();
			logic.MovePiece(new Position("E", "2"), new Position("E", "4"));
			logic.MovePiece(new Position("D", "7"), new Position("D", "6"));
			logic.MovePiece(new Position("G", "1"), new Position("F", "3"));
			logic.MovePiece(new Position("C", "8"), new Position("E", "6"));
			logic.MovePiece(new Position("F", "1"), new Position("D", "3"));
			logic.MovePiece(new Position("B", "8"), new Position("C", "6"));
			logic.MovePiece(new Position("E", "1"), new Position("E", "2"));
			System.Diagnostics.Debug.WriteLine(logic.Board.ToString());
			System.Diagnostics.Debug.WriteLine("!!!!!!!!!!!! About to get rook for Black Castle Kingside");
			var rookPos = logic.validRookLocationsForCastling();	//TODO: this is the problem line
			System.Diagnostics.Debug.WriteLine("!!!!!!!!!!!! About to Black Castle Kingside with rook at " + rookPos[0]);
			logic.Castle(rookPos[0]);
			System.Diagnostics.Debug.WriteLine(logic.Board.ToString());
			System.Diagnostics.Debug.WriteLine("!!!!!!!!!!!! About to get rook for White Castle Queenside");
			rookPos = logic.validRookLocationsForCastling();
			System.Diagnostics.Debug.WriteLine("!!!!!!!!!!!! About to White Castle Queenside");
			logic.Castle(rookPos[0]);
		}

	}
}
﻿using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using WizardsChess.Chess;


namespace WizardsChessTest
{
	[TestClass]
	public class PieceTypeTest
	{
		[TestMethod]
		public void TestStringConversion()
		{
			Assert.AreEqual(PieceType.King, PieceTypeMethods.Parse("king"));
			Assert.AreEqual(PieceType.King, PieceTypeMethods.Parse("KING"));
			Assert.AreEqual(PieceType.Queen, PieceTypeMethods.Parse("queen"));
			Assert.AreEqual(PieceType.Queen, PieceTypeMethods.Parse("QUEEN"));
			Assert.AreEqual(PieceType.Bishop, PieceTypeMethods.Parse("bishop"));
			Assert.AreEqual(PieceType.Bishop, PieceTypeMethods.Parse("BISHOP"));
			Assert.AreEqual(PieceType.Knight, PieceTypeMethods.Parse("knight"));
			Assert.AreEqual(PieceType.Knight, PieceTypeMethods.Parse("KNIGHT"));
			Assert.AreEqual(PieceType.Rook, PieceTypeMethods.Parse("rook"));
			Assert.AreEqual(PieceType.Rook, PieceTypeMethods.Parse("ROOK"));
			Assert.AreEqual(PieceType.Rook, PieceTypeMethods.Parse("castle"));
			Assert.AreEqual(PieceType.Rook, PieceTypeMethods.Parse("CASTLE"));
			Assert.AreEqual(PieceType.Pawn, PieceTypeMethods.Parse("pawn"));
			Assert.AreEqual(PieceType.Pawn, PieceTypeMethods.Parse("PAWN"));
		}

		[TestMethod]
		[ExpectedException(typeof(ArgumentException))]
		public void TestFailedStringConversion()
		{
			PieceTypeMethods.Parse("");
			PieceTypeMethods.Parse("test");
		}
	}
}
﻿//using System;
//using Microsoft.VisualStudio.TestTools.UnitTesting;
//using WizardsChess.Movement.Drv;
//using WizardsChessTest.Mocks.Movement.Drv;
//using WizardsChess.Movement;

//namespace WizardsChessTest.Mocks.Movement
//{
//	[TestClass]
//	public class CalibratedMotorMoverTest
//	{
//		public CalibratedMotorMoverTest()
//		{
//			mockMotor = new MockMotor();
//			locator = new MotorLocator(mockMotor, mockMotor);
//			stepCounter = new StepCounter(locator, new MockGpio());
//			topInterrupter = new MockPhotoInterrupter(1, stepsPerGridUnit - 5, stepsPerGridUnit + 5, mockMotor);
//			bottomInterrupter = new MockPhotoInterrupter(-1, -stepsPerGridUnit - 5, -stepsPerGridUnit + 5, mockMotor);
//		}

//		[TestCategory("Motor Calibration")]
//		[TestMethod]
//		public void TestMotorCalibration()
//		{
//			constructFreshCalibrator();
//			calibratedMover.CalibrateAsync().Wait();
//			Assert.AreEqual(50, (int)Math.Round(calibratedMover.StepsPerGridUnit), "Steps per grid unit were incorrect.");
//			Assert.IsTrue(calibratedMover.StepPosition < -50, $"Final position {calibratedMover.StepPosition} should be less than -50.");
//		}

//		[TestCategory("Motor Calibration")]
//		[TestMethod]
//		public void TestOffsetMotorCalibration()
//		{
//			mockMotor.Position = 20;
//			constructFreshCalibrator();
//			calibratedMover.CalibrateAsync().Wait();
//			Assert.AreEqual(50, (int)Math.Round(calibratedMover.StepsPerGridUnit), "Steps per grid unit were incorrect.");
//			Assert.IsTrue(calibratedMover.StepPosition < -50, $"Final position {calibratedMover.StepPosition} should be less than -50.");
//		}

//		[TestCategory("Motor Calibration")]
//		[TestMethod]
//		public void TestMotorCalibrationFromAboveInterrupts()
//		{
//			mockMotor.Position = 100;
//			constructFreshCalibrator();
//			calibratedMover.CalibrateAsync().Wait();
//			Assert.AreEqual(50, (int)Math.Round(calibratedMover.StepsPerGridUnit), "Steps per grid unit were incorrect.");
//			Assert.IsTrue(calibratedMover.StepPosition < -50, $"Final position {calibratedMover.StepPosition} should be less than -50.");
//		}

//		[TestCategory("Motor Calibration")]
//		[TestMethod]
//		public void TestMotorCalibrationFromBelowInterrupts()
//		{
//			mockMotor.Position = -100;
//			constructFreshCalibrator();
//			calibratedMover.CalibrateAsync().Wait();
//			Assert.AreEqual(50, (int)Math.Round(calibratedMover.StepsPerGridUnit), "Steps per grid unit were incorrect.");
//			Assert.IsTrue(calibratedMover.StepPosition > 50, $"Final position {calibratedMover.StepPosition} should be greater than 50.");
//		}

//		private void constructFreshCalibrator()
//		{
//			calibratedMover = new CalibratedMotorMover(Axis.X, 3, -3, 20, mockMotor, stepCounter, topInterrupter, bottomInterrupter);
//		}

//		private IStepCounter stepCounter;
//		private MockMotor mockMotor;
//		private IMotorLocator locator;
//		private IPhotoInterrupter topInterrupter;
//		private IPhotoInterrupter bottomInterrupter;

//		private int stepsPerGridUnit = 50;

//		private CalibratedMotorMover calibratedMover;
//	}
//}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv;
using WizardsChess.Movement.Drv.Events;

namespace WizardsChessTest.Mocks.Movement.Drv
{
	class MockGpio : IGpioPin
	{
		public event GpioValueChangedEventHandler ValueChanged;

		public int PinNum { get; }

		public MockGpio() { PinNum = 1; }

		protected void onValueChanged()
		{
			ValueChanged?.Invoke(this, new GpioValueChangedEventArgs(_edge));
		}

		protected GpioEdge edge
		{
			get { return _edge; }
			set
			{
				if (value != _edge)
				{
					_edge = value;
					onValueChanged();
				}
			}
		}

		protected GpioValue value
		{
			get { return _value; }
			set
			{
				if (value != _value)
				{
					_value = value;
					if (_value == GpioValue.High)
					{
						edge = GpioEdge.RisingEdge;
					}
					else
					{
						edge = GpioEdge.FallingEdge;
					}
				}
			}
		}

		public GpioValue Read()
		{
			return value;
		}

		public void Write(GpioValue val)
		{
			value = val;
		}

		private GpioEdge _edge;
		private GpioValue _value;
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv;

namespace WizardsChessTest.Mocks.Movement.Drv
{
	class MockMagnet : IMagnetDrv
	{
		public bool IsOn
		{
			get;
			private set;
		}

		public void TurnOff()
		{
			IsOn = false;
		}

		public void TurnOn()
		{
			IsOn = true;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using WizardsChess.Movement;
using WizardsChess.Movement.Drv;
using WizardsChess.Movement.Drv.Events;

namespace WizardsChessTest.Mocks.Movement.Drv
{
	class MockMotor : MockGpio, IMotorDrv
	{
		private MockMotor() : base()
		{
			direction = MoveDirection.Stopped;
			previousDirection = MoveDirection.Stopped;
			NumTicks = 0;
			timer = new Timer(motorTick, null, Timeout.Infinite, Timeout.Infinite);
		}

		public static MockMotor Create()
		{
			var motor = new MockMotor();
			var info = new MotorInformation(Axis.X, motor);
			motor.Information = info;
			return motor;
		}

		public MoveDirection Direction
		{
			get
			{
				lock(lockObject)
				{
					return direction;
				}
			}
			set
			{
				if (direction == value)
				{
					return;
				}
				System.Diagnostics.Debug.WriteLine($"Setting the mock motor to {direction}.");
				lock (lockObject)
				{
					previousDirection = direction;
					direction = value;
				}
				HandleMotorDirectionChanged(direction);
			}
		}

		public MoveDirection PreviousDirection
		{
			get
			{
				lock(lockObject)
				{
					return previousDirection;
				}
			}
		}

		public int NumTicks
		{
			get; set;
		}

		public IMotorInformation Information
		{
			get { return information; }
			set
			{
				information = value as MotorInformation;
			}
		}


		public MoveDirection GetLatestActiveMoveDirection()
		{
			lock(lockObject)
			{
				if (direction != MoveDirection.Stopped)
				{
					return direction;
				}
				else
				{
					return previousDirection;
				}
			}
		}

		public void HandleMotorDirectionChanged(MoveDirection dir)
		{
			if (dir != MoveDirection.Stopped)
			{
				information.SetDirection(dir);
				runTheMotor();
			}
			else
			{
				Task.Delay(150).ContinueWith((prev) => {
					timer.Change(Timeout.Infinite, Timeout.Infinite);
				});
			}
		}

		private MoveDirection direction;
		private MoveDirection previousDirection;
		private MotorInformation information;
		private Timer timer;
		private object lockObject = new object();

		private void runTheMotor()
		{
			NumTicks = 0;
			timer.Change(0, 1);
		}

		private void motorTick(object state)
		{
			if (edge == GpioEdge.FallingEdge)
			{
				edge = GpioEdge.RisingEdge;
			}
			else
			{
				NumTicks++;
				edge = GpioEdge.FallingEdge;
			}
		}
	}
}
﻿using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Threading.Tasks;
using WizardsChess.Movement;
using WizardsChess.Movement.Drv;

namespace WizardsChessTest.Mocks.Movement.Drv
{
	[TestClass]
	public class MockMotorTest
	{
		[TestMethod]
		public void TestMockMotor()
		{
			var motor = MockMotor.Create();

			var pos = 0;
			motor.Direction = MoveDirection.Forward;
			Task.Delay(200).Wait();
			pos = motor.NumTicks;
			Assert.IsTrue(pos > 0, "Motor did not increase NumTicks when going forwards");
			motor.Direction = MoveDirection.Stopped;
			Task.Delay(300).Wait();
			Assert.IsTrue(motor.NumTicks > pos, "Motor did no extra ticks after stopping");
			Assert.AreEqual(MoveDirection.Stopped, motor.Information.Direction, "MotorInformation seems wrong.");
			pos = 0;
			motor.Direction = MoveDirection.Backward;
			Task.Delay(200).Wait();
			Assert.IsTrue(motor.NumTicks > pos, "Motor did not increase NumTicks when going backwards");
			pos = motor.NumTicks;
			motor.Direction = MoveDirection.Stopped;
			Task.Delay(300).Wait();
			Assert.IsTrue(motor.NumTicks > pos, "Motor did no extra ticks after stopping");
			Assert.AreEqual(MoveDirection.Stopped, motor.Information.Direction, "MotorInformation seems wrong.");
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement;
using WizardsChess.Movement.Drv;
using WizardsChess.Movement.Drv.Events;
using WizardsChess.Movement.Events;

namespace WizardsChessTest.Mocks.Movement.Drv
{
	class MockPhotoInterrupter : MockGpio, IPhotoInterrupter
	{
		public int GridPosition { get; }

		public int StepPosition { get; set; }

		public MockPhotoInterrupter(int gridPosition, int lowerMotorStepPosition, int upperMotorStepPosition, IMotorLocator mtrLocator, MockMotor mtr) : base()
		{
			GridPosition = gridPosition;
			StepPosition = (upperMotorStepPosition + lowerMotorStepPosition) / 2;
			UpperStepPosition = upperMotorStepPosition;
			LowerStepPosition = lowerMotorStepPosition;

			value = GpioValue.High;

			locator = mtrLocator;
			motor = mtr;
			locator.PositionChanged += positionChanged;
		}

		public int UpperStepPosition;
		public int LowerStepPosition;
		private IMotorLocator locator;
		private MockMotor motor;
		
		private void positionChanged(object sender, PositionChangedEventArgs e)
		{
			if (locator.Position == LowerStepPosition)
			{
				if (motor.Direction == MoveDirection.Forward)
				{
					value = GpioValue.Low;
				}
				else if (motor.Direction == MoveDirection.Backward)
				{
					value = GpioValue.High;
				}
			}
			else if (locator.Position == UpperStepPosition)
			{
				if (motor.Direction == MoveDirection.Forward)
				{
					value = GpioValue.High;
				}
				else if (motor.Direction == MoveDirection.Backward)
				{
					value = GpioValue.Low;
				}
			}
		}
	}
}
﻿using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using WizardsChessTest.Mocks.Movement.Drv;
using WizardsChess.Movement;
using WizardsChess.Movement.Drv;

namespace WizardsChessTest.Mocks.Movement
{
	[TestClass]
	public class MotorCalibratorTest
	{
		[TestMethod]
		public void TestMotorCalibrationBasic()
		{
			setup();

			calibrator.CalibrateAsync().Wait();
			checkResults();
		}

		[TestMethod]
		public void TestMotorCalibrationAboveInterrupts()
		{
			setup();

			locator.ShiftPosition(10);
			calibrator.CalibrateAsync().Wait();
			checkResults();
		}

		[TestMethod]
		public void TestMotorCalibrationBelowInterrupts()
		{
			setup();

			locator.ShiftPosition(-10);
			calibrator.CalibrateAsync().Wait();
			checkResults();
		}

		[TestMethod]
		public void TestMotorCalibratorDetectingDecalibration()
		{
			setup();

			calibrator.CalibrateAsync().Wait();

			topInterrupt.UpperStepPosition = 20;
			topInterrupt.LowerStepPosition = 18;
			bottomInterrupt.UpperStepPosition = 12;
			bottomInterrupt.LowerStepPosition = 10;

			mover.GoToPositionAsync(0).Wait();
			mover.GoToPositionAsync(13).Wait();

			Assert.AreEqual(CalibrationState.NeedsCalibrating, calibrator.State, "Calibrator didn't register the need for recalibrating.");
			calibrator.CalibrateAsync().Wait();

			var oldTopIntPos = topIntPos;
			topIntPos = 4;
			var oldBottomIntPos = bottomIntPos;
			bottomIntPos = -4;
			var oldStepsPerGrid = stepsPerGrid;
			stepsPerGrid = 4;
			checkResults();
			topIntPos = oldTopIntPos;
			bottomIntPos = oldBottomIntPos;
			stepsPerGrid = oldStepsPerGrid;
		}

		private MockMotor mockMotor;
		private IMotorLocator locator;
		private IPositionSignaler signaler;
		private IMotorMover mover;
		private MockPhotoInterrupter topInterrupt;
		private MockPhotoInterrupter bottomInterrupt;
		private IMotorCalibrator calibrator;

		private int upperTopIntPos = 8;
		private int lowerTopIntPos = 6;
		private int topIntPos = 7;
		private int upperBottomIntPos = -6;
		private int lowerBottomIntPos = -8;
		private int bottomIntPos = -7;
		private int stepsPerGrid = 7;

		private void setup()
		{
			mockMotor = MockMotor.Create();
			locator = new MotorLocator(new MockGpio(), mockMotor.Information);
			signaler = new PositionSignaler(locator);
			mover = new MotorMover(3, signaler, locator, mockMotor);
			topInterrupt = new MockPhotoInterrupter(1, lowerTopIntPos, upperTopIntPos, locator, mockMotor);
			bottomInterrupt = new MockPhotoInterrupter(-1, lowerBottomIntPos, upperBottomIntPos, locator, mockMotor);
			calibrator = new MotorCalibrator(-5, 5, mover, mockMotor.Information, topInterrupt, bottomInterrupt);
		}

		private void checkResults()
		{
			Assert.AreEqual(CalibrationState.Ready, calibrator.State, "Calibrator isn't in the Ready state after callibration.");
			Assert.AreEqual(topIntPos, topInterrupt.StepPosition, "Top interrupt was calibrated to the wrong place");
			Assert.AreEqual(bottomIntPos, bottomInterrupt.StepPosition, "Bottom interrupt was calibrated to the wrong place.");
			Assert.AreEqual(stepsPerGrid, calibrator.StepsPerGridUnit, "Steps per grid unit was calibrated wrong.");
		}
	}
}
﻿using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using WizardsChessTest.Mocks.Movement.Drv;
using WizardsChess.Movement;
using WizardsChess.Movement.Drv;
using System.Threading.Tasks;

namespace WizardsChessTest.Mocks.Movement
{
	[TestClass]
	public class MotorLocatorTest
	{
		[TestMethod]
		public void TestMotorLocatorForwardMove()
		{
			var mockMotor = MockMotor.Create();
			var locator = new MotorLocator(new MockGpio(), mockMotor.Information);

			mockMotor.Direction = MoveDirection.Forward;

			Task.Delay(75).Wait();

			mockMotor.Direction = MoveDirection.Stopped;

			Task.Delay(300).Wait();

			Assert.AreEqual(mockMotor.NumTicks, locator.Position, $"Locator count {locator.Position} did not match motor ticks {mockMotor.NumTicks}.");
		}

		[TestMethod]
		public void TestMotorLocatorBackwardMove()
		{
			var mockMotor = MockMotor.Create();
			var locator = new MotorLocator(new MockGpio(), mockMotor.Information);

			mockMotor.Direction = MoveDirection.Backward;

			Task.Delay(75).Wait();

			mockMotor.Direction = MoveDirection.Stopped;

			Task.Delay(300).Wait();

			Assert.AreEqual(mockMotor.NumTicks, -locator.Position, $"Locator count {locator.Position} did not match motor ticks {mockMotor.NumTicks}.");
		}

		[TestMethod]
		public void TestMotorLocatorForwardShiftBackwardMove()
		{
			var mockMotor = MockMotor.Create();
			var locator = new MotorLocator(new MockGpio(), mockMotor.Information);

			mockMotor.Direction = MoveDirection.Forward;

			Task.Delay(75).Wait();

			mockMotor.Direction = MoveDirection.Stopped;

			Task.Delay(300).Wait();

			Assert.AreEqual(mockMotor.NumTicks, locator.Position, $"Locator count {locator.Position} did not match motor ticks {mockMotor.NumTicks} on forward move.");

			var previousPosition = locator.Position;
			locator.ShiftPosition(50);
			Assert.AreEqual(previousPosition + 50, locator.Position, $"Locator count {locator.Position} did not expected position after shift.");
			mockMotor.NumTicks = 0;
			mockMotor.Direction = MoveDirection.Backward;

			Task.Delay(75).Wait();

			mockMotor.Direction = MoveDirection.Stopped;

			Task.Delay(300).Wait();

			Assert.AreEqual(-mockMotor.NumTicks + previousPosition + 50, locator.Position, $"Locator count {locator.Position} did not match motor ticks after backward move.");
		}
	}
}
﻿using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using WizardsChess.Movement;
using WizardsChess.Movement.Drv;
using WizardsChessTest.Mocks.Movement.Drv;
using System.Threading.Tasks;

namespace WizardsChessTest.Mocks.Movement
{
	[TestClass]
	public class MotorMoverTest
	{
		[TestMethod]
		public void TestMotorMoverForwardMove()
		{
			constructMotorMover();

			int targetPos = 12;
			int finalPos = motorMover.GoToPositionAsync(targetPos).Result;
			Assert.AreEqual(motorLocator.Position, finalPos, $"Motor mover result {finalPos} does not match motorLocator position {motorLocator.Position}");
			Assert.IsTrue(finalPos > targetPos, $"Motor final position {finalPos} did not make sense with target {targetPos}.");
			Assert.IsTrue(motorMover.EstimatedOvershoot != 0, "Estimated overshoot was still 0 after a successful move.");
		}

		[TestMethod]
		public void TestMotorMoverForwardThenBackwardMove()
		{
			constructMotorMover();

			int targetPos = 12;
			int finalPos = motorMover.GoToPositionAsync(targetPos).Result;
			Assert.AreEqual(motorLocator.Position, finalPos, $"Motor mover result {finalPos} does not match motorLocator position {motorLocator.Position}");
			Assert.IsTrue(finalPos > targetPos, $"Motor final position {finalPos} did not make sense with target {targetPos}.");
			Assert.IsTrue(motorMover.EstimatedOvershoot != 0, "Estimated overshoot was still 0 after a successful move.");
			var previousOvershoot = motorMover.EstimatedOvershoot;

			targetPos = -12;
			finalPos = motorMover.GoToPositionAsync(targetPos).Result;
			Assert.AreEqual(motorLocator.Position, finalPos, $"Motor mover result {finalPos} does not match motorLocator position {motorLocator.Position}");
			Assert.IsTrue(finalPos < targetPos, $"Motor final position {finalPos} did not make sense with target {targetPos}.");
			Assert.IsTrue(motorMover.EstimatedOvershoot >= previousOvershoot, "Estimated overshoot did not increase after a second successful move.");
		}

		[TestMethod]
		public void TestMotorMoverCancel()
		{
			constructMotorMover();
			((MotorMover)motorMover).Dispose();
			motorMover = new MotorMover(0, positionSignaler, motorLocator, mockMotor);

			int targetPos = 300;
			var moveTask = motorMover.GoToPositionAsync(targetPos);
			Task.Delay(30).Wait();
			motorMover.CancelMove();
			while(mockMotor.Information.Direction != MoveDirection.Stopped)
			{
				Task.Delay(30).Wait();
			}
			Task.Delay(60).Wait();
			Assert.IsTrue(moveTask.IsCompleted, "Move task did not end after cancellation.");
			int finalPos = moveTask.Result;
			Assert.AreEqual(motorLocator.Position, finalPos, $"Motor mover result {finalPos} does not match motorLocator position {motorLocator.Position}");
			Assert.IsTrue(finalPos < targetPos, $"Motor final position {finalPos} did not make sense with target {targetPos}.");
			Assert.AreEqual(0, motorMover.EstimatedOvershoot, "EstimatedOvershoot should not update if a move is canceled.");
		}

		[TestMethod]
		public void TestMotorStall()
		{
			constructMotorMover();
			((MotorMover)motorMover).Dispose();
			motorMover = new MotorMover(0, positionSignaler, motorLocator, mockMotor);

			int targetPos = 400;
			var moveTask = motorMover.GoToPositionAsync(targetPos);
			Task.Delay(60).Wait();
			mockMotor.HandleMotorDirectionChanged(MoveDirection.Stopped);
			while (mockMotor.Information.Direction != MoveDirection.Stopped)
			{
				Task.Delay(30).Wait();
			}
			Task.Delay(30).Wait();
			int finalPos = moveTask.Result;
			Assert.IsTrue(finalPos < targetPos, "Counted all the way to the target position instead of stalling.");
			Assert.AreEqual(motorLocator.Position, finalPos, "MotorLocator position did not match finalPos");
			Assert.AreEqual(MoveDirection.Stopped, mockMotor.Direction, "Motor was not stopped after move stalled.");
			Assert.AreEqual(0, motorMover.EstimatedOvershoot, "EstimatedOvershoot shouldn't be updated with a stall.");
		}

		[TestMethod]
		public void TestOverlappingMotorMoves()
		{
			constructMotorMover();

			int initialTargetPos = 300;
			var moveTask = motorMover.GoToPositionAsync(initialTargetPos);
			Task.Delay(60).Wait();
			int targetPos = motorLocator.Position + 10;
			var startTime = DateTime.Now;
			var secondMoveTask = motorMover.GoToPositionAsync(targetPos);
			int finalPos = secondMoveTask.Result;
			var timeDifference = DateTime.Now - startTime;
			Assert.IsTrue(timeDifference < TimeSpan.FromMilliseconds(700), "Interrupting move took longer than expected");
			Task.Delay(30).Wait();
			Assert.IsTrue(moveTask.IsCompleted, "First move did not complete.");
			Task.Delay(15).Wait();
			Assert.AreEqual(motorLocator.Position, finalPos, "Motor locator did not match finalPos");
			Assert.IsTrue(motorLocator.Position < initialTargetPos, $"Motor went past or met the initial target position of {initialTargetPos} to {motorLocator.Position}/");
			Assert.IsTrue((finalPos - targetPos) > motorMover.EstimatedOvershoot, "Estimated offset was over its expected value.");
		}

		private IMotorMover motorMover;
		private IMotorLocator motorLocator;
		private IPositionSignaler positionSignaler;
		private MockMotor mockMotor;

		private void constructMotorMover()
		{
			mockMotor = MockMotor.Create();
			motorLocator = new MotorLocator(new MockGpio(), mockMotor.Information);
			positionSignaler = new PositionSignaler(motorLocator);
			motorMover = new MotorMover(3, positionSignaler, motorLocator, mockMotor);
		}

		private TimeSpan convertToTimeout(int pos)
		{
			int distance = Math.Abs(pos - motorLocator.Position);
			return TimeSpan.FromMilliseconds(distance * 30 + 20);
		}
	}
}
﻿using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using WizardsChessTest.Mocks.Movement.Drv;
using WizardsChess.Movement.Drv;
using WizardsChess.Movement.Drv.Events;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Text;
using WizardsChess.Movement;
using WizardsChess.Movement.Events;

namespace WizardsChessTest.Mocks.Movement
{
	[TestClass]
	public class PositionSignalerTest
	{
		[TestCategory(nameof(PositionSignaler))]
		[TestMethod]
		public void TestPositionSignalerConstruction()
		{
			mockMotor = MockMotor.Create();
			motorLocator = new MotorLocator(new MockGpio(), mockMotor.Information);
			positionSignaler = new PositionSignaler(motorLocator);

			positionSignaler.ReachedPosition += finishedCounting;
		}

		[TestCategory(nameof(PositionSignaler))]
		[TestMethod]
		public void TestPositionSignalerBasic()
		{
			TestPositionSignalerConstruction();

			resetTestVariables();

			isCounting = true;
			var expectedPosition = 10;
			positionSignaler.SignalOnPosition(expectedPosition);
			runMotor();
			while (isCounting)
			{
				Task.Delay(60).Wait();
			}
			Assert.AreEqual(expectedPosition, positionOnTargetReached, "Step count was off.");
			checkForErrors();
		}

		[TestCategory(nameof(PositionSignaler))]
		[TestMethod]
		public void TestPositionSignalerOverlappingCounts()
		{
			TestPositionSignalerConstruction();
			resetTestVariables();

			isCounting = true;
			positionSignaler.SignalOnPosition(50);
			runMotor();
			Task.Delay(30).Wait();
			var shorterTarget = motorLocator.Position + 5;
			positionSignaler.SignalOnPosition(shorterTarget);
			isCounting = true;
			while (isCounting)
			{
				Task.Delay(30).Wait();
			}
			var firstTargetPositionReached = positionOnTargetReached;
			Assert.AreEqual(shorterTarget, firstTargetPositionReached, $"Overlapping count step did not reset target count properly. Counted to position {firstTargetPositionReached}.");
			Task.Delay(convertPositionToTimeout(50)).Wait();
			Assert.AreEqual(firstTargetPositionReached, positionOnTargetReached, "Counted more steps after delay!");
			checkForErrors();
		}

		[TestCategory(nameof(PositionSignaler))]
		[TestMethod]
		public void TestPositionSignalerStopMidCount()
		{
			TestPositionSignalerConstruction();
			resetTestVariables();

			isCounting = true;
			positionSignaler.SignalOnPosition(50);
			runMotor();
			Task.Delay(90).Wait();
			var pos = motorLocator.Position;
			positionSignaler.SignalOnPosition(pos);
			while(mockMotor.Information.Direction != MoveDirection.Stopped)
			{
				Task.Delay(30).Wait();
			}
			Assert.AreEqual(pos, positionOnTargetReached, $"Overlapping count step did not reset target count properly. Expected {pos} and reached target {positionOnTargetReached}.");
			checkForErrors();
		}

		[TestCategory(nameof(PositionSignaler))]
		[TestMethod]
		public void TestPositionSignalerStepAfterStopping()
		{
			TestPositionSignalerConstruction();
			resetTestVariables();

			isCounting = true;
			positionSignaler.SignalOnPosition(10);
			runMotor();
			var start = DateTime.Now;
			while (mockMotor.Information.Direction != MoveDirection.Stopped)
			{
				Task.Delay(30).Wait();
			}
			var end = DateTime.Now;

			runMotor(MoveDirection.Backward);
			Task.Delay((end - start).Milliseconds + 60).Wait();
			stopMotor();

			checkForErrors();
		}

		private MockMotor mockMotor;
		private IMotorLocator motorLocator;
		private PositionSignaler positionSignaler;

		private int positionOnTargetReached;

		private bool isCounting;
		private bool isPassing;

		private Queue<string> errorMessages = new Queue<string>();

		private void finishedCounting(object sender, PositionChangedEventArgs e)
		{
			var pos = motorLocator.Position;
			assert(pos == e.Position, $"Expected {pos} at finished counting, received {e.Position}.");
			assert(isCounting, "Finished counting when not in counting state.");
			positionOnTargetReached = e.Position;
			stopMotor();
			isCounting = false;
		}

		private TimeSpan convertPositionToTimeout(int position)
		{
			return TimeSpan.FromMilliseconds((position - motorLocator.Position) * 30);
		}

		private void stopMotor()
		{
			mockMotor.Direction = MoveDirection.Stopped;
		}

		private void runMotor(MoveDirection direction = MoveDirection.Forward)
		{
			mockMotor.Direction = direction;
		}

		private void resetTestVariables()
		{
			isPassing = true;
		}

		private void assert(bool pass, string message)
		{
			if (!pass)
			{
				isPassing = false;
				errorMessages.Enqueue(message);
			}
		}

		private void checkForErrors()
		{
			if (isPassing)
				return;
			StringBuilder errorStrings = new StringBuilder();
			foreach(var msg in errorMessages)
			{
				errorStrings.Append(msg);
			}
			Assert.IsTrue(isPassing, errorStrings.ToString());
		}
	}
}
﻿using System;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using WizardsChess.Chess;
using WizardsChess.Chess.Pieces;
using WizardsChess.Movement;
using System.Threading.Tasks;

namespace WizardsChessTest
{
	[TestClass]
	public class MovementPlannerTest1
	{
		[TestMethod]
		public void MovePlannerInitializationCheck()
		{
			ChessBoard board = new ChessBoard();
			MovePlanner planner = new MovePlanner(board);
			ChessPiece TestPiece = board.PieceAt(4, 1);
			Assert.AreEqual(TestPiece.Type, PieceType.Pawn);
		}

		[TestMethod]
		public void SampleMoveCheckingPawnMoving()
		{
			//String correctPoints = "start move\n[12, 3]\n[12, 7]\nend move \n";
			//Set moves
			//White King Pawn to E5
			Point2D moveW1Start = new Point2D(4, 1);    //start location of the first white move (0-7, 0-7)
			Point2D moveW1End = new Point2D(4, 3);

			List<IList<Point2D>> paths = new List<IList<Point2D>>();
			//String printString = "";
			ChessBoard board = new ChessBoard();
			MovePlanner planner = new MovePlanner(board);
			paths = planner.PlanMove(moveW1Start, moveW1End);
			board.MovePiece(new Position(moveW1Start), new Position(moveW1End));
			//System.Diagnostics.Debug.Write(printString);
			Assert.AreEqual("[1, -5]", paths[0][0].ToString());
			Assert.AreEqual("[1, -1]", paths[0][1].ToString());
			//Assert.AreEqual(correctPoints, printString);

		}

		[TestMethod]
		public void CapturingMovementTest() //tests move taking by enacting an impossible pawn zoom
		{
			//White King Pawn to E2 (magic!)
			Point2D moveW1Start = new Point2D(4, 1);    //start location of the first white move (0-7, 0-7)
			Point2D moveW1End = new Point2D(4, 6);

			List<IList<Point2D>> paths = new List<IList<Point2D>>();
			ChessBoard board = new ChessBoard();
			MovePlanner planner = new MovePlanner(board);
			System.Diagnostics.Debug.WriteLine("about to get path");
			paths = planner.PlanMove(moveW1Start, moveW1End);
			//board.MovePiece(new Position(moveW1Start), new Position(moveW1End));

			Assert.AreEqual("[1, 5]", paths[0][0].ToString());
			Assert.AreEqual("[1, 6]", paths[0][1].ToString());
			Assert.AreEqual("[-9, 6]", paths[0][2].ToString());
			Assert.AreEqual("[-9, 7]", paths[0][3].ToString());
			Assert.AreEqual("[-11, 7]", paths[0][4].ToString());
			Assert.AreEqual("[1, -5]", paths[1][0].ToString());
			Assert.AreEqual("[1, 5]", paths[1][1].ToString());
		}

		/*
		[TestMethod]
		public void SampleMoveCheckingKnightTaking()	//won't work without board updating
		{
			//Set moves
			//White King Side Knight to F6
			Point2D moveW1Start = new Point2D(6, 0);	//start location of the first white move (0-7, 0-7)
			Point2D moveW1End = new Point2D(5, 2);
			//Black King Pawn to E4
			Point2D moveB1Start = new Point2D(4, 6);
			Point2D moveB1End = new Point2D(4, 4);
			//White Knight takes Black Pawn at E4
			Point2D moveW2Start = moveW1End;
			Point2D moveW2End = moveB1End;

			List<List<List<Point2D>>> listOfPaths = new List<List<List<Point2D>>>();
			//String printString = "";
			ChessBoard board = new ChessBoard();
			MovementPlanner planner = new MovementPlanner(board);
			listOfPaths.Add(planner.Move(moveW1Start, moveW1End));
			listOfPaths.Add(planner.Move(moveB1Start, moveB1End));
			listOfPaths.Add(planner.Move(moveW2Start, moveW2End));

			Assert.AreEqual("[16, 1]", listOfPaths[0][0][0].ToString());
			Assert.AreEqual("[15, 1]", listOfPaths[0][0][1].ToString());
			Assert.AreEqual("[15, 5]", listOfPaths[0][0][2].ToString());
			Assert.AreEqual("[14, 5]", listOfPaths[0][0][3].ToString());
			Assert.AreEqual("[12, 13]", listOfPaths[1][0][0].ToString());
			Assert.AreEqual("[12, 9]", listOfPaths[1][0][1].ToString());
			Assert.AreEqual("[12, 9]", listOfPaths[2][0][0].ToString());
			Assert.AreEqual("[12, 10]", listOfPaths[2][0][1].ToString());
			Assert.AreEqual("[2, 10]", listOfPaths[2][0][2].ToString());
			Assert.AreEqual("[2, 15]", listOfPaths[2][0][3].ToString());
			Assert.AreEqual("[0, 15]", listOfPaths[2][0][4].ToString());
			Assert.AreEqual("[14, 5]", listOfPaths[2][1][0].ToString());
			Assert.AreEqual("[13, 5]", listOfPaths[2][1][1].ToString());
			Assert.AreEqual("[13, 9]", listOfPaths[2][1][2].ToString());
			Assert.AreEqual("[12, 9]", listOfPaths[2][1][3].ToString());
			
		}*/
		[TestMethod]
		public async Task VisualizerTest1()
		{
			ChessLogic logic = new ChessLogic();
			MovePlanner planner = new MovePlanner(logic.Board);
			MovePerformerVisualizer visualizer = new MovePerformerVisualizer();
			MoveManager manager = new MoveManager(planner, visualizer);

			visualizer.ResetBoardRep();
			visualizer.PrintBoardRep();

			List<Position[]> moves = new List<Position[]>();

			Position[] move = new Position[2];	//can't reuse move like that, apparently
			move[0] = new Position("E", "2");
			move[1] = new Position("E", "4");
			moves.Add(move);
			foreach (var movement in moves)
			{
				logic.IsMoveValid(movement[0], movement[1]);
				await manager.MoveAsync(movement[0], movement[1]);
				logic.MovePiece(movement[0], movement[1]);
			}
		}

		[TestMethod]
		public async Task VisualizerTest2CastlingAndTaking()
		{
			ChessLogic logic = new ChessLogic();
			MovePlanner planner = new MovePlanner(logic.Board);
			MovePerformerVisualizer visualizer = new MovePerformerVisualizer();
			MoveManager manager = new MoveManager(planner, visualizer);

			visualizer.ResetBoardRep();
			visualizer.PrintBoardRep();

			List<Position[]> moves = new List<Position[]>();

			Position[] move1 = new Position[2];
			move1[0] = new Position("E", "2");
			move1[1] = new Position("E", "4");
			moves.Add(move1);
			Position[] move2 = new Position[2];
			move2[0] = new Position("D", "7");
			move2[1] = new Position("D", "5");
			moves.Add(move2);
			Position[] move3 = new Position[2];
			move3[0] = new Position("G", "1");
			move3[1] = new Position("F", "3");
			moves.Add(move3);
			Position[] move4 = new Position[2];
			move4[0] = new Position("C", "8");
			move4[1] = new Position("E", "6");
			moves.Add(move4);
			Position[] move5 = new Position[2];
			move5[0] = new Position("F", "1");
			move5[1] = new Position("C", "4");
			moves.Add(move5);
			Position[] move6 = new Position[2];
			move6[0] = new Position("B", "8");
			move6[1] = new Position("C", "6");
			moves.Add(move6);
			Position[] move7 = new Position[2];
			move7[0] = new Position("E", "1");
			move7[1] = new Position("E", "2");
			moves.Add(move7);

			System.Diagnostics.Debug.WriteLine(logic.Board.ToString());

			foreach (var movement in moves)
			{
				Assert.AreEqual(logic.validRookLocationsForCastling().Count, 0);    //assert castling invalid when things in the way

				System.Diagnostics.Debug.WriteLine(movement[0].ToString() + "\t" + movement[1].ToString());
				Assert.AreEqual(logic.IsMoveValid(movement[0], movement[1]),true);
				await manager.MoveAsync(movement[0], movement[1]);
				logic.MovePiece(movement[0], movement[1]);
				System.Diagnostics.Debug.WriteLine(logic.Board.ToString());
			}

			moves.Clear();
			Position[] move8 = new Position[2];
			move8[0] = new Position("D", "5");
			move8[1] = new Position("E", "4");
			moves.Add(move8);
			Position[] move9 = new Position[2];
			move9[0] = new Position("C", "4");
			move9[1] = new Position("E", "6");
			moves.Add(move9);
			Position[] move10 = new Position[2];
			move10[0] = new Position("E", "4");
			move10[1] = new Position("F", "3");
			moves.Add(move10);
			Position[] move11 = new Position[2];
			move11[0] = new Position("A", "2");
			move11[1] = new Position("A", "3");
			moves.Add(move11);

			foreach (var movement in moves)
			{
				System.Diagnostics.Debug.WriteLine(movement[0].ToString() + "\t" + movement[1].ToString());
				Assert.AreEqual(logic.IsMoveValid(movement[0], movement[1]), true);
				await manager.MoveAsync(movement[0], movement[1]);
				logic.MovePiece(movement[0], movement[1]);
				System.Diagnostics.Debug.WriteLine(logic.Board.ToString());
			}

			//verify that castling while in check stops castling
			Assert.AreEqual(logic.validRookLocationsForCastling().Count, 0);

			moves.Clear();
			Position[] move12 = new Position[2];
			move12[0] = new Position("F", "7");
			move12[1] = new Position("E", "6");
			moves.Add(move12);
			Position[] move13 = new Position[2];
			move13[0] = new Position("E", "2");
			move13[1] = new Position("F", "3");
			moves.Add(move13);

			foreach (var movement in moves)
			{
				System.Diagnostics.Debug.WriteLine(movement[0].ToString() + "\t" + movement[1].ToString());
				Assert.AreEqual(logic.IsMoveValid(movement[0], movement[1]), true);
				await manager.MoveAsync(movement[0], movement[1]);
				logic.MovePiece(movement[0], movement[1]);
				System.Diagnostics.Debug.WriteLine(logic.Board.ToString());
			}

			System.Diagnostics.Debug.WriteLine("Black castles kingside.");
			var rookLocationForBlackCastle = logic.validRookLocationsForCastling();
			Assert.AreEqual(rookLocationForBlackCastle.Count, 1);
			await manager.CastleAsync(rookLocationForBlackCastle[0], logic.Board.GetKingCol());
			logic.Castle(rookLocationForBlackCastle[0]);
			System.Diagnostics.Debug.WriteLine(logic.Board.ToString());

			System.Diagnostics.Debug.WriteLine("White castles queenside.");
			var rookLocationForWhiteCastle = logic.validRookLocationsForCastling();
			Assert.AreEqual(rookLocationForWhiteCastle.Count, 1);
			await manager.CastleAsync(rookLocationForWhiteCastle[0], logic.Board.GetKingCol());
			logic.Castle(rookLocationForWhiteCastle[0]);
			System.Diagnostics.Debug.WriteLine(logic.Board.ToString());
		}

		[TestMethod]
		public async Task VisualizerTest3BasicUndo()
		{
			ChessLogic logic = new ChessLogic();
			MovePlanner planner = new MovePlanner(logic.Board);
			MovePerformerVisualizer visualizer = new MovePerformerVisualizer();
			MoveManager manager = new MoveManager(planner, visualizer);

			visualizer.ResetBoardRep();
			visualizer.PrintBoardRep();

			List<Position[]> moves = new List<Position[]>();

			Position[] move1 = new Position[2];
			move1[0] = new Position("E", "2");
			move1[1] = new Position("E", "4");
			moves.Add(move1);
			Position[] move2 = new Position[2];
			move2[0] = new Position("D", "7");
			move2[1] = new Position("D", "5");
			moves.Add(move2);

			System.Diagnostics.Debug.WriteLine(logic.Board.ToString());

			foreach (var movement in moves)
			{
				Assert.AreEqual(logic.validRookLocationsForCastling().Count, 0);    //assert castling invalid when things in the way

				System.Diagnostics.Debug.WriteLine(movement[0].ToString() + "\t" + movement[1].ToString());
				Assert.AreEqual(logic.IsMoveValid(movement[0], movement[1]), true);
				await manager.MoveAsync(movement[0], movement[1]);
				logic.MovePiece(movement[0], movement[1]);
				System.Diagnostics.Debug.WriteLine(logic.Board.ToString());
			}

			for (int i = 0; i < moves.Count; i++)
			{
				await manager.UndoMoveAsync();
				logic.UndoMove();
				System.Diagnostics.Debug.WriteLine(logic.Board.ToString());
			}

		}
	}
}
﻿using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using WizardsChess.Chess;
using WizardsChess.Movement;
using WizardsChess.Movement.Drv;
using WizardsChess.VoiceControl;
using WizardsChess.VoiceControl.Commands;
using WizardsChess.VoiceControl.Events;
using WizardsChessTest.Mocks.Movement.Drv;

namespace WizardsChessTest.Movement
{
	[TestClass]
	public class MoveTesting
	{
		[TestMethod]
		public void TestMoveComponentCompilation()
		{
			ChessLogic logic = new ChessLogic();
			movePlanner = new MovePlanner(logic.Board);
			constructAnAxis(ref xMover, ref xCalibrator, ref xPreciseMover, ref xGridMover);
			constructAnAxis(ref yMover, ref yCalibrator, ref yPreciseMover, ref yGridMover);
			var magnet = new MockMagnet();
			movePerformer = new MovePerformer(xGridMover, yGridMover, magnet);
			moveManager = new MoveManager(movePlanner, movePerformer);
		}

		[TestMethod]
		public void TestMovePerformerMove()
		{
			TestMoveComponentCompilation();

			int targetX = 2;
			int targetY = -2;
			movePerformer.CalibrateAsync().Wait();
			var list = new List<Point2D>() { new Point2D(-1, -1), new Point2D(targetX, targetY) };
			movePerformer.MovePieceAsync(list).Wait();
			Assert.AreEqual(targetX, xGridMover.GridPosition,"The xMotor didn't end where expected.");
			Assert.AreEqual(targetY, yGridMover.GridPosition, "The yMotor didn't end where expected.");
			Assert.AreEqual(targetX, (int)Math.Round((float)xPreciseMover.Position / xPreciseMover.StepsPerGridUnit), "xPreciseMover was not where expected.");
			Assert.AreEqual(targetY, (int)Math.Round((float)yPreciseMover.Position / yPreciseMover.StepsPerGridUnit), "yPreciseMover was not where expected.");

		}

		[TestMethod]
		public void TestMovePerformerOneMoveInList()
		{
			TestMoveComponentCompilation();

			movePerformer.MovePieceAsync(new List<Point2D>() { new Point2D(1, 1) }).Wait();
			Assert.AreEqual(0, xGridMover.GridPosition, "The xMotor didn't end where expected.");
			Assert.AreEqual(0, yGridMover.GridPosition, "The yMotor didn't end where expected.");
			Assert.AreEqual(0, (int)Math.Round((float)xPreciseMover.Position / xPreciseMover.StepsPerGridUnit), "xPreciseMover was not where expected.");
			Assert.AreEqual(0, (int)Math.Round((float)yPreciseMover.Position / yPreciseMover.StepsPerGridUnit), "yPreciseMover was not where expected.");
		}

		[TestMethod]
		public void TestMovePerformerEmptyList()
		{
			TestMoveComponentCompilation();

			movePerformer.MovePieceAsync(new List<Point2D>() { new Point2D(1, 1) }).Wait();
			Assert.AreEqual(0, xGridMover.GridPosition, "The xMotor didn't end where expected.");
			Assert.AreEqual(0, yGridMover.GridPosition, "The yMotor didn't end where expected.");
			Assert.AreEqual(0, (int)Math.Round((float)xPreciseMover.Position / xPreciseMover.StepsPerGridUnit), "xPreciseMover was not where expected.");
			Assert.AreEqual(0, (int)Math.Round((float)yPreciseMover.Position / yPreciseMover.StepsPerGridUnit), "yPreciseMover was not where expected.");
		}

		private IMotorMover xMover;
		private IMotorMover yMover;
		private IMotorCalibrator xCalibrator;
		private IMotorCalibrator yCalibrator;
		private IPreciseMotorMover xPreciseMover;
		private IPreciseMotorMover yPreciseMover;
		private IGridMotorMover xGridMover;
		private IGridMotorMover yGridMover;
		private IMovePerformer movePerformer;
		private IMovePlanner movePlanner;
		private IMoveManager moveManager;

		private void constructAnAxis(ref IMotorMover mover, ref IMotorCalibrator calibrator, ref IPreciseMotorMover preciseMover, ref IGridMotorMover gridMover)
		{
			var motor = MockMotor.Create();
			var locator = new MotorLocator(new MockGpio(), motor.Information);
			var signaler = new PositionSignaler(locator);
			mover = new MotorMover(3, signaler, locator, motor);
			var topInterrupter = new MockPhotoInterrupter(1, 4, 6, locator, motor);
			var bottomInterrupter = new MockPhotoInterrupter(-1, -6, -4, locator, motor);
			calibrator = new MotorCalibrator(-5, 5, mover, motor.Information, topInterrupter, bottomInterrupter);
			preciseMover = new PreciseMotorMover(mover, calibrator);
			gridMover = new GridMotorMover(preciseMover);
		}
	}
}
﻿using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using WizardsChess.VoiceControl.Commands;
using System.Collections.Generic;

namespace WizardsChessTest.VoiceControl.Commands
{
	[TestClass]
	public class CommandTest
	{
		public CommandTest()
		{
			var cmdParams = new Dictionary<string, IReadOnlyList<string>>();
			cmdParams.Add("action", new List<string>{ "move" });
			commandParams = cmdParams;
			commandType = CommandType.Move;			
		}

		private IReadOnlyDictionary<string, IReadOnlyList<string>> commandParams;
		private CommandType commandType;

		[TestMethod]
		public void TestTypeConstruction()
		{
			var cmd = new Command(CommandType.Yes);
			Assert.AreEqual(CommandType.Yes, cmd.Type);
		}

		[TestMethod]
		public void TestStringConstruction()
		{
			var cmd2 = new Command(commandParams);
			Assert.AreEqual(commandType, cmd2.Type);
		}
	}
}
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.VoiceControl.Commands;
using WizardsChess.Chess.Pieces;
using WizardsChess.Movement;

namespace WizardsChess.Chess
{
	public class ChessBoard: IChessBoard
	{
		public ChessBoard()
		{
			boardMatrix = new ChessPiece[Size, Size];
			WhoseTurn = ChessTeam.White;
			setBoard();
			capturedPiecesByTeam[ChessTeam.White] = new List<ChessPiece>();
			capturedPiecesByTeam[ChessTeam.Black] = new List<ChessPiece>();
		}

		/// <summary>
		/// Sets up the board with the black and white pieces in their starting arrangement.
		/// </summary>
		private void setBoard()
		{
			// initialize the rooks
			boardMatrix[WhiteBackRow, LeftRookCol] = new Rook(ChessTeam.White);
			boardMatrix[WhiteBackRow, RightRookCol] = new Rook(ChessTeam.White);
			boardMatrix[BlackBackRow, LeftRookCol] = new Rook(ChessTeam.Black);
			boardMatrix[BlackBackRow, RightRookCol] = new Rook(ChessTeam.Black);

			// initialize the knights
			boardMatrix[WhiteBackRow, LeftKnightCol] = new Knight(ChessTeam.White);
			boardMatrix[WhiteBackRow, RightKnightCol] = new Knight(ChessTeam.White);
			boardMatrix[BlackBackRow, LeftKnightCol] = new Knight(ChessTeam.Black);
			boardMatrix[BlackBackRow, RightKnightCol] = new Knight(ChessTeam.Black);

			// initialize the Bishops
			boardMatrix[WhiteBackRow, LeftBishopCol] = new Bishop(ChessTeam.White);
			boardMatrix[WhiteBackRow, RightBishopCol] = new Bishop(ChessTeam.White);
			boardMatrix[BlackBackRow, LeftBishopCol] = new Bishop(ChessTeam.Black);
			boardMatrix[BlackBackRow, RightBishopCol] = new Bishop(ChessTeam.Black);

			// initialize the Queens
			boardMatrix[WhiteBackRow, QueenCol] = new Queen(ChessTeam.White);
			boardMatrix[BlackBackRow, QueenCol] = new Queen(ChessTeam.Black);

			// initialize the Kings
			boardMatrix[WhiteBackRow, KingCol] = new King(ChessTeam.White);
			boardMatrix[BlackBackRow, KingCol] = new King(ChessTeam.Black);

			// initialize pawns
			for (int col = 0; col < Size; col++)
			{
				boardMatrix[WhiteFrontRow, col] = new Pawn(ChessTeam.White);
				boardMatrix[BlackFrontRow, col] = new Pawn(ChessTeam.Black);
			}

			setupPieceLocationsDictionary();
		}

		//sets up pieceLocationByType
		private void setupPieceLocationsDictionary()
		{
			for (int row = 0; row < Size; row ++)
			{
				for (int col = 0; col < Size; col++)
				{
					var piece = boardMatrix[row, col];
					if (piece != null)
					{
						if (!pieceLocationsByType.ContainsKey(piece.Type))
						{
							pieceLocationsByType[piece.Type] = new List<Point2D>();
						}
						pieceLocationsByType[piece.Type].Add(new Movement.Point2D(col, row));
					}
				}
			}
		}

		/// <summary>
		/// Moves the piece from startPosition to endPosition. Kills the piece at endPosition if it exists.
		/// Throws an InvalidOperationException if this is an invalid move.	//TODO: take this out once it's no longer done here
		/// </summary>
		/// <param name="startPosition"></param>
		/// <param name="endPosition"></param>
		public void MovePiece(Position startPosition, Position endPosition)
		{
			MoveSpecification move = new MoveSpecification(startPosition, endPosition);
			
			// Kill the piece at the destination, if there is one
			var endPiece = internalPieceAt(endPosition);
			if (endPiece != null)
			{
				move.Capture = endPosition;
				capturedPiecesByTeam[endPiece.Team].Add(endPiece);
				
				// Remove a killed piece from our valid pieceLocationsByType list
				var listOfEndPieceType = pieceLocationsByType[endPiece.Type];
				listOfEndPieceType.Remove(new Point2D(endPosition));
			} //TODO: else if en passant

			var movingPiece = internalPieceAt(startPosition);
			//Move the moving piece in boardMatrix
			SetPieceAt(endPosition, movingPiece);
			SetPieceAtToNull(startPosition);

			if (!movingPiece.HasMoved)  //note changes if this is a piece's first move in it and in pastMoves
			{
				movingPiece.HasMoved = true;
				move.HasMovedChange = true;
			}
			// Replace the old position for this piece with the new position in the pieceLocationsByType list
			var listOfMovingPieceType = pieceLocationsByType[movingPiece.Type];
			listOfMovingPieceType.Remove(new Point2D(startPosition));
			listOfMovingPieceType.Add(new Point2D(endPosition));

			pastMoves.Add(move);
			changeTurn();
		}

		public void Castle(Point2D initialRookPoint)
		{
			int rookDir = Math.Sign(initialRookPoint.X - KingCol);	//calculates the direction of the rook from the king initially

			//Move the King in boardMatrix
			Position initialKingPos = new Position(KingCol, initialRookPoint.Y);
			var king = internalPieceAt(initialKingPos);
			Position finalKingPos = new Position(KingCol + 2 * rookDir, initialRookPoint.Y);
			SetPieceAt(finalKingPos, king);
			SetPieceAtToNull(initialKingPos);

			king.HasMoved = true;    //update King's HasMoved
			//Replace the old position for the King with the new position in the pieceLocationsByType list
			var listOfPieceType = pieceLocationsByType[PieceType.King];
			listOfPieceType.Remove(new Point2D(initialKingPos));
			listOfPieceType.Add(new Point2D(finalKingPos));

			//Move this Rook in boardMatrix
			var rook = internalPieceAt(initialRookPoint);
			Position finalRookPos = new Position(KingCol + rookDir, initialRookPoint.Y);
			SetPieceAt(finalRookPos, rook);
			SetPieceAtToNull(initialRookPoint);

			rook.HasMoved = true;  //update Rook's HasMoved
			//Replace the old position for this Rook with the new position in the pieceLocationsByType list
			listOfPieceType = pieceLocationsByType[PieceType.Rook];
			listOfPieceType.Remove(initialRookPoint);
			listOfPieceType.Add(new Point2D(finalRookPos));	//TODO: figure out if this creation is unnecessary and casting is done automatically.

			MoveSpecification move = new MoveSpecification(new Position(initialRookPoint), finalRookPos, null, true);
			pastMoves.Add(move);
			changeTurn();
		}
		public void changeTurn()
		{
			if (WhoseTurn == ChessTeam.Black)
			{
				WhoseTurn = ChessTeam.White;
			}
			else
			{
				WhoseTurn = ChessTeam.Black;
			}
		}

		//undoes the last move (can be called repeatedly)
		public void UndoMove()
		{
			MoveSpecification lastMove = pastMoves[pastMoves.Count - 1];
			if (lastMove.Castle)
			{
				undoCastle(lastMove);
			}
			else //not a castle
			{
				undoRegularMove(lastMove);
			}
			pastMoves.RemoveAt(pastMoves.Count - 1);
			changeTurn();
		}

		//undoes non-castle moves
		private void undoRegularMove(MoveSpecification lastMove)
		{
			var movingPiece = internalPieceAt(lastMove.End);    //get the move that is being undone
			if (lastMove.HasMovedChange)    //set a piece to unmoved if this was a move that changed that status
			{
				movingPiece.HasMoved = false;
			}

			//Perform reverse move upon boardMatrix
			SetPieceAt(lastMove.Start, internalPieceAt(lastMove.End));
			SetPieceAtToNull(lastMove.End);

			//Replace the old position for this piece with the new position in the pieceLocationsByType list
			var listOfMovingPieceType = pieceLocationsByType[internalPieceAt(lastMove.Start).Type];
			listOfMovingPieceType.Remove(lastMove.End);
			listOfMovingPieceType.Add(lastMove.Start);

			if (lastMove.Capture != null)   //if move being undone has a capture location, restore the most recently taken other team's piece to that location
			{
				SetPieceAt((Position)lastMove.Capture, capturedPiecesByTeam[WhoseTurn][capturedPiecesByTeam[WhoseTurn].Count - 1]); //restores captured piece to boardMatrix
				capturedPiecesByTeam[WhoseTurn].RemoveAt(capturedPiecesByTeam.Count - 1);   //removes restored captured piece from the list of capturedPiecesByTeam for WhoseTurn, which hasn't been changed yet

				// Add a captured piece to our valid pieceLocationsByType list
				var listOfCapturedPieceType = pieceLocationsByType[internalPieceAt((Position)lastMove.Capture).Type];
				listOfCapturedPieceType.Add((Position)lastMove.Capture);
			}
		}

		//undoes castle moves
		private void undoCastle(MoveSpecification lastMove)
		{
			int rookSideDir = Math.Sign(lastMove.Start.Column - KingCol);    //calculates the direction of the rook from the king initially

			//Move King back in BoardMatrix
			Position movedKingPos = new Position(KingCol, lastMove.Start.Column);
			var king = internalPieceAt(movedKingPos);
			Position unmovedKingPos = new Position(KingCol, lastMove.Start.Row);
			SetPieceAt(unmovedKingPos, king);
			SetPieceAtToNull(movedKingPos);

			king.HasMoved = false;  //set King HasMoved to false
									//Update King Location in pieceLocationsByType
			var listOfPieceType = pieceLocationsByType[PieceType.King];
			listOfPieceType.Remove(movedKingPos);
			listOfPieceType.Add(unmovedKingPos);

			//Move Rook back
			var rook = internalPieceAt(lastMove.End);
			SetPieceAt(new Point2D(lastMove.End), king);
			SetPieceAtToNull(new Point2D(lastMove.Start));

			rook.HasMoved = false;  //set Rook HasMoved to false
									//Update Rook Location in pieceLocationsByType
			listOfPieceType = pieceLocationsByType[PieceType.Rook];
			listOfPieceType.Remove(new Point2D(lastMove.End));
			listOfPieceType.Add(new Point2D(lastMove.Start));
		}

		//TODO: board reset

		private void SetPieceAt(Position p, ChessPiece piece)
		{
			boardMatrix[p.Row, p.Column] = piece;
		}

		private void SetPieceAt(Point2D p2, ChessPiece piece)
		{
			boardMatrix[p2.Y, p2.X] = piece;
		}

		private void SetPieceAtToNull(Position p)
		{
			boardMatrix[p.Row, p.Column] = null;
		}

		private void SetPieceAtToNull(Point2D p2)
		{
			boardMatrix[p2.Y, p2.X] = null;
		}


		//Prints a representation of the board.
		public override string ToString()
		{
			int presentedRow;
			StringBuilder strBuild = new StringBuilder();
			strBuild.Append("\n\tA\tB\tC\tD\tE\tF\tG\tH\n");
			for (int row = Size - 1; row >= 0; row--)
			{
				presentedRow = row + 1;
				strBuild.Append(presentedRow).Append("\t");
				for (int col = 0; col < Size; col++)
				{
					var piece = boardMatrix[row, col];
					if (piece != null)
					{
						strBuild.Append(piece.ToShortString());
					}
					strBuild.Append("\t");
				}
				strBuild.Append("\n");
			}
			return strBuild.ToString();
		}

		//piece accessor by x and y indexes
		public ChessPiece internalPieceAt(int x, int y)
		{
			return boardMatrix[y, x];
		}

		//piece accessor by Point2D
		public ChessPiece internalPieceAt(Point2D point)
		{
			return boardMatrix[point.Y, point.X];
		}

		//piece accessor by Position
		private ChessPiece internalPieceAt(Position pos)
		{
			return boardMatrix[pos.Row, pos.Column];
		}

		//piece accessor by x and y indexes
		public ChessPiece PieceAt(int x, int y)
        {
			if (boardMatrix[y,x] != null)
			{
				return boardMatrix[y, x].DeepCopy();
			}
			else
			{
				return null;
			}
		}

		//piece accessor by Point2D
        public ChessPiece PieceAt(Point2D point)
        {
			if (boardMatrix[point.Y, point.X] != null)
			{
				return boardMatrix[point.Y, point.X].DeepCopy();
			}
			else
			{
				return null;
			}
		}

		//piece accessor by Position
		public ChessPiece PieceAt(Position pos)
		{
			if (boardMatrix[pos.Row, pos.Column] != null) {
				return boardMatrix[pos.Row, pos.Column].DeepCopy();
			}
			else
			{
				return null;
			}
		}
		
        //access the number of captured pieces on a team
        public int NumCapturedPieces(ChessTeam team)
        {
            return capturedPiecesByTeam[team].Count;
        }

        public const int Size = 8;
        public ChessTeam WhoseTurn;	//TODO: move to ChessLogic? Change to Private (and add modifiers and an accessor?)

		private ChessPiece[,] boardMatrix;
		private Dictionary<PieceType, IList<Point2D>> pieceLocationsByType = new Dictionary<PieceType, IList<Point2D>>();    //TODO: figure out how to expose pieceLocationsByType properly
		public Dictionary<PieceType, IList<Point2D>> PieceLocationsByType
		{
			get
			{
				var temp = pieceLocationsByType;
				return temp;
			}
		}
		private IDictionary<ChessTeam, IList<ChessPiece>> capturedPiecesByTeam = new Dictionary<ChessTeam, IList<ChessPiece>>();
		public IDictionary<ChessTeam, IList<ChessPiece>> CapturedPiecesByTeam
		{
			get
			{
				var temp = capturedPiecesByTeam;
				return temp;
			}
		}
		private List<MoveSpecification> pastMoves = new List<MoveSpecification>();
		public IList<MoveSpecification> PastMoves
		{
			get
			{
				var temp = pastMoves;
				return temp;
			}
		}
		public const int WhiteBackRow = 0;
		public const int WhiteFrontRow = 1;
		public const int BlackBackRow = 7;
		public const int BlackFrontRow = 6;
		public const int LeftRookCol = 0;
		public const int LeftKnightCol = 1;
		public const int LeftBishopCol = 2;
		public const int KingCol = 3;
		public const int QueenCol = 4;
		public const int RightBishopCol = 5;
		public const int RightKnightCol = 6;
		public const int RightRookCol = 7;
		public int GetWhiteBackRow()
		{
			return WhiteBackRow;
		}
		public int GetWhiteFrontRow()
		{
			return WhiteFrontRow;
		}
		public int GetBlackBackRow()
		{
			return BlackBackRow;
		}
		public int GetBlackFrontRow()
		{
			return BlackFrontRow;
		}
		public int GetLeftRookCol()
		{
			return LeftRookCol;
		}
		public int GetLeftKnightCol()
		{
			return LeftKnightCol;
		}
		public int GetLeftBishopCol()
		{
			return LeftBishopCol;
		}
		public int GetKingCol()
		{
			return KingCol;
		}
		public int GetQueenCol()
		{
			return QueenCol;
		}
		public int GetRightBishopCol()
		{
			return RightBishopCol;
		}
		public int GetRightKnightCol()
		{
			return RightKnightCol;
		}
		public int GetRightRookCol()
		{
			return RightRookCol;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WizardsChess.Chess;
using WizardsChess.Chess.Pieces;
using WizardsChess.Movement;

namespace WizardsChess.Chess
{
	public class ChessLogic
	{
		public ChessLogic ()
		{
			board = new ChessBoard();
		}

		//Checks for pieces of a certain type that can move to 
		public ISet<Position> FindPotentialPiecesForMove(PieceType piece, Position destination)
		{
			var pieceLocationList = board.PieceLocationsByType[piece];

			var potentialPiecePositions = new HashSet<Position>();

			foreach (var location in pieceLocationList)
			{
				if (IsMoveValid(new Position(location), destination))
				{
					potentialPiecePositions.Add(new Position(location));
				}
			}

			return potentialPiecePositions;
		}

		/// <summary>
		/// Moves the piece from startPosition to endPosition. Kills the piece at endPosition if it exists.
		/// Throws an InvalidOperationException if this is an invalid move.
		/// </summary>
		public void MovePiece (Position startPosition, Position endPosition)
		{
			if (!IsMoveValid(startPosition, endPosition))
			{
				System.Diagnostics.Debug.WriteLine($"Preforming illegal move.");
				//throw new InvalidOperationException($"Cannot complete invalid move from {startPosition} to {endPosition}");
			}

			board.MovePiece(startPosition, endPosition);
		}

		public void UndoMove ()
		{
			if (board.PastMoves.Count == 0)
			{
				System.Diagnostics.Debug.WriteLine($"No previous moves to undo.");
				//throw new InvalidOperationException($"No previous moves to undo.");
			}
			else
			{
				board.UndoMove();
			}
		}

		/// <summary>
		/// Checks if the move from startPosition to endPosition is valid.
		/// Assumes that startPosition and endPosition are valid parameters.
		/// Returns false if there is no piece at startPosition, or the piece otherwise
		/// cannot complete the requested move.
		/// </summary>
		/// <param name="startPosition">The position of the piece to move.</param>
		/// <param name="endPosition">The destination of the piece.</param>
		/// <returns></returns>
		public bool IsMoveValid(Position startPosition, Position endPosition)
		{
			// Get piece at input location
			ChessPiece startPiece = board.PieceAt(startPosition);
			ChessPiece endPiece = board.PieceAt(endPosition);

			// If there is no piece at the requested start position, return false
			if (startPiece == null)
			{
				return false;
			}

			// It's not this pieces turn to move
			if (startPiece.Team != board.WhoseTurn)
			{
				return false;
			}

			IReadOnlyList<Vector2D> pieceMovementVectors;
			if (endPiece == null)
			{
				pieceMovementVectors = startPiece.GetAllowedMotionVectors();
			}
			else
			{
				// If there is a piece in the way and it is a friendly piece, then we can't move there
				if (endPiece.Team == startPiece.Team)
				{
					return false;
				}
				pieceMovementVectors = startPiece.GetAttackMotionVectors();
			}

			var requestedMoveVector = (Point2D)endPosition - startPosition;

			try
			{
				var matchingMove = pieceMovementVectors.Single(v => v == requestedMoveVector);
			}
			catch (InvalidOperationException)
			{
				// Could not retrieve a matching vector from the allowed moves
				return false;
			}

			// If the piece can jump, it doesn't matter if something is in the way
			if (startPiece.CanJump)
			{
				return true;
			}

			return isPathClear(startPosition, endPosition);
		}

		//TODO: overload of: public bool IsMoveValid(Point2D, Point2D)

		public bool DoesMoveCapture(Position start, Position end)	//TODO: make MovePiece use DoesMoveCapture and CaptureLocation methods
		{
			if (board.PieceAt(end) != null)
			{
				return true;
			}
			//TODO: add en passant conditions
			else
			{
				return false;
			}
		}

		public Position CaptureLocation(Position start, Position end)
		{
			return end;	//remove this to implement en passant
			/*if (board.PieceAt(end)!=null)
			{
				return end;
			}
			else
			{
				//en passant location
			}*/
			
		}

		private bool isPathClear(Point2D startPosition, Point2D endPosition)
		{
			var requestedMoveVector = endPosition - startPosition;

			// Increment from the startPosition to the endPosition, checking nothing is in the way
			var unitVector = requestedMoveVector.GetUnitVector();
			var nextPosition = startPosition + unitVector;
			while (nextPosition != endPosition)
			{
				if (board.PieceAt(nextPosition) != null)
				{
					return false;
				}
				unitVector = (endPosition - nextPosition).GetUnitVector();
				nextPosition = nextPosition + unitVector;
			}

			return true;
		}

		//TODO: detect Checkmate

		public void Castle(Point2D rookPos)
		{
			board.Castle(rookPos);
		}

		public List<Point2D> validRookLocationsForCastling()
		{
			List<Point2D> validRookLocations = new List<Point2D>();
			var kingLocations = board.PieceLocationsByType[PieceType.King];

			Point2D kingLocation = new Point2D();
			ChessPiece king;

			foreach (var aKingLocation in kingLocations)
			{
				if (board.PieceAt(aKingLocation).Team == board.WhoseTurn)
				{
					kingLocation = aKingLocation;
				}
			}
			if (kingLocation == null)
			{
				throw new InvalidOperationException($"missing king");
			}
			king = board.PieceAt(kingLocation);
			if (king.HasMoved == true || inCheck(kingLocation, board.WhoseTurn))	//if the king has moved or is in check, castling is not legal
			{
				return validRookLocations;
			}
			var allRookLocations = board.PieceLocationsByType[PieceType.Rook];
			int x;
			int y;
			int kingToRookDir;
			bool thisSideOkay;

			foreach (var location in allRookLocations)
			{
				var rook = board.PieceAt(location);
				//if the rook in question is on the team that isn't moving, has move, it cannot provide a legal castle
				if (rook.Team == board.WhoseTurn && rook.HasMoved == false && isPathClear(kingLocation, location))
				{
					thisSideOkay = true;
					y = kingLocation.Y;
					kingToRookDir = Math.Sign(location.X - kingLocation.X);
					for (x = kingLocation.X + kingToRookDir; x != location.X; x += kingToRookDir) {
						if (board.PieceAt(x,y) != null)	//if any squares between the king and the rook contain piece, that castle is illegal
						{
							thisSideOkay = false;
							break;	//could be replaced with a double break of sorts, and then the valid rook adding could be without an if statement
						}
						if (Math.Abs(kingLocation.X-x) <= 2) //if the square is 1 or two over from the king, the king will pass through it, so it must not be in check
						{
							if (inCheck(new Point2D(x, y), board.WhoseTurn))
							{
								thisSideOkay = false;
								break;  //could be replaced with a double break of sorts, and then the valid rook adding could be without an if statement
							}
						}
					}
					if (thisSideOkay)
					{
						validRookLocations.Add(location);
					}
				}
			}
			return validRookLocations;
		}

		//TODO: en passant (this might be implemented through other methods)

		// Checks if the player to move's king is in check
		public bool inCheck()
		{
			var kingLocations = board.PieceLocationsByType[PieceType.King];
			Point2D kingLocation = new Point2D();
			foreach (var aKingLocation in kingLocations)
			{
				if (board.PieceAt(aKingLocation).Team == board.WhoseTurn)
				{
					kingLocation = aKingLocation;
				}
			}
			if (kingLocation == null)
			{
				throw new InvalidOperationException($"missing king");
			}
			return inCheck(kingLocation, board.WhoseTurn);
		}

		// Checks if the specified location is in check for the specified team 
		public bool inCheck(Point2D checkPoint, ChessTeam Turn)
		{
			int i, j;
			for (i = 0; i < ChessBoard.Size; i++)
			{
				for (j = 0; j < ChessBoard.Size; j++)
				{
					var piece = board.PieceAt(i, j);
					if (piece != null && piece.Team != Turn)
					{
						if (IsCheckMoveValid(new Point2D(i,j), checkPoint))
						{
							return true;
						}
					}
				}
			}
			return false;	//TODO: remove this
		}

		public bool IsCheckMoveValid(Point2D startPoint, Point2D endPoint)
		{
			// Get piece at input location
			ChessPiece startPiece = board.PieceAt(startPoint);
			ChessPiece endPiece = board.PieceAt(endPoint);

			// If there is no piece at the requested start position, return false
			if (startPiece == null)
			{
				return false;
			}

			IReadOnlyList<Vector2D> pieceMovementVectors;
			if (endPiece == null)
			{
				pieceMovementVectors = startPiece.GetAllowedMotionVectors();
			}
			else
			{
				// If there is a piece in the way and it is a friendly piece, then we can't move there
				if (endPiece.Team == startPiece.Team)
				{
					return false;
				}
				pieceMovementVectors = startPiece.GetAttackMotionVectors();
			}

			var requestedMoveVector = endPoint - startPoint;

			try
			{
				var matchingMove = pieceMovementVectors.Single(v => v == requestedMoveVector);
			}
			catch (InvalidOperationException)
			{
				// Could not retrieve a matching vector from the allowed moves
				return false;
			}

			// If the piece can jump, it doesn't matter if something is in the way
			if (startPiece.CanJump)
			{
				return true;
			}

			return isPathClear(startPoint, endPoint);
		}

		//piece accessor by x and y indexes
		public ChessPiece PieceAt(int x, int y)
		{
			return board.PieceAt(x, y);
		}

		//piece accessor by Point2D
		public ChessPiece PieceAt(Point2D point)
		{
			return board.PieceAt(point);
		}

		//piece accessor by Position
		public ChessPiece PieceAt(Position pos)
		{
			return board.PieceAt(pos);
		}

		private ChessBoard board;
		public IChessBoard Board
		{
			get
			{
				return board;
			}
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Chess
{
	public enum ChessTeam
	{
		White,
		Black
	}
}
using System;
using System.Collections.Generic;
using WizardsChessApp.Game.Pieces;

// To control the motions
namespace WizardsChessApp.Game {
	
	class GameManager
	{
		// Global variables
		private static ChessTeam Turn = ChessTeam.White;

		// To play the game
		public void playGame(){
			System.Diagnostics.Debug.WriteLine("Blue Goes first");

			bool execute = false;
			while(true){
				System.Diagnostics.Debug.WriteLine("Enter Start Location");
				string Start = System.Diagnostics.Debug.ReadLine();
				System.Diagnostics.Debug.WriteLine("Enter End Location");
				string End = System.Diagnostics.Debug.ReadLine();

				int[] startCoordinates = getFormattedCoordinate(Start);
				int[] endCoordinates = getFormattedCoordinate(End);

				// Get team of piece to check if it's their turn
				String teamName = grid[startCoordinates[0],startCoordinates[1]].getTeamName();

				if(teamName=="Team1" && team1Turn){
					execute=true;
				}else if(teamName=="Team2" && !team1Turn){
					execute=true;
				}
				
				if(execute){
					bool status = checkMoveValidity(startCoordinates,endCoordinates);

					System.Diagnostics.Debug.WriteLine("Move from "+Start+" to "+End+" is: ");

					if(status){
						System.Diagnostics.Debug.WriteLine("Valid!");
						movePiece(startCoordinates[0],startCoordinates[1],endCoordinates[0],endCoordinates[1]);
						printNodes();

						if(team1Turn){
							team1Turn=false;
							}else{
							team1Turn=true;
						}


					}else{
						System.Diagnostics.Debug.WriteLine("Invalid!");
						printNodes();
					}
					// reset variables 
					execute=false;
			
				}else{
					System.Diagnostics.Debug.Write("You cannot move. It is ");
					if(team1Turn){
						System.Diagnostics.Debug.Write(" Blues Turn\n");
					}else{
						System.Diagnostics.Debug.Write(" Reds Turn\n");
					}
					printNodes();
				}

			}
		}


		// To see if move valid
		public bool CheckMoveValidity(Position startCoordinates, int[] endCoordinates){
			bool isValidMove = false;

			// Get piece at input location
			ChessPiece startPiece = grid[startCoordinates[0],startCoordinates[1]];
			ChessPiece endPiece = grid[endCoordinates[0],endCoordinates[1]];
			
			// To hold object values
			string startPieceName;
			string startPieceTeam;
			string endPieceTeam;
			bool attemptMoveCheck = false;

			// To break if objects in the way
			bool objectsInWay = false;

			// // check if valid move then check if anything blocking seperatly
			if (startPiece != null){
				startPieceName = startPiece.getName();
				System.Diagnostics.Debug.WriteLine(startPieceName);
				startPieceTeam = startPiece.getTeamName();


				// If there is a piece there we need to check if friendly or not
				if(endPiece != null){
					// if is not a friently piece can move there
					endPieceTeam = endPiece.getTeamName();
					if(endPieceTeam!=startPieceTeam){
						attemptMoveCheck = true;
					}

				}else{
					attemptMoveCheck = true;
				}
				if(attemptMoveCheck){
					// This tile is empty, we can look into moving here
					List<int[]> allowedMoveVectors = startPiece.getAllowedMotionVector();

					// given start and end coordinates, let us subtract to get vector
					int xVector = endCoordinates[0]-startCoordinates[0];
					int yVector = endCoordinates[1]-startCoordinates[1];

					// Check to see if move is possible in constraints of piece movement allowment
					foreach (int[] allocatedMoveSet in allowedMoveVectors){
						// if pawn, knight, king, need exact
						if(startPieceName=="Pawn" || startPieceName=="Knight" || startPieceName=="King"){
							foreach (int[] vector in allowedMoveVectors){
								if(vector[0]==xVector && vector[1]==yVector){
									isValidMove = true;
								}
							}
						}else{
							// All of these can have variants of allowed movement vectors
							foreach (int[] vector in allowedMoveVectors){

								if(startPieceName=="Bishop"){
									if(xVector!=0 && yVector !=0){
										if(xVector%vector[0]==yVector%vector[1]){
											// Check for collisions here
											if(checkCollisions(startCoordinates,endCoordinates,vector)){
												isValidMove=true;
												break;
											}
											
										}
									}
								}


								if(startPieceName=="Queen"){
									System.Diagnostics.Debug.WriteLine(xVector);
									System.Diagnostics.Debug.WriteLine(yVector);
									if(xVector!= 0 && yVector!=0){
										//System.Diagnostics.Debug.WriteLine("Diag");
										if(Math.Abs(xVector) == Math.Abs(yVector)){
											// Check for collisions here
											if(checkCollisions(startCoordinates,endCoordinates,vector)){

												isValidMove=true;
												break;
											}
										}
									}else if((xVector==0 && yVector!=0)||(yVector==0 && xVector!=0)){
										//System.Diagnostics.Debug.WriteLine("X Dir");
										
										if(checkCollisions(startCoordinates,endCoordinates,vector)){


											isValidMove = true;
											break;
										}
										
									}
								}

								if(startPieceName=="Rook"){
									if((xVector==0 && yVector!=0)||(yVector==0 && xVector!=0)){
										
										// Only run if relevant to this particular search
										
											if(checkCollisions(startCoordinates,endCoordinates,vector)){
												isValidMove = true;
												break;
											}
											/*
											else{
												objectsInWay=true;
												break;
											}
											*/
										
										
										
									}
								}	
								
							}
						}
						if(isValidMove){
							break;
						}else if(objectsInWay){
							break;
						}
					}

				}

			}else{
				System.Diagnostics.Debug.WriteLine("Piece 1 doesn't exist. Valid input needed to proceed");
			}

			return isValidMove;
		}

		// To check whether there will be collisions
		// Input Start coordinate, end coordinates, vector
		// output if any collisions. True if okay to move
		public bool checkCollisions(int[] startCoordinates,int[] endCoordinates,int[] vector){
			bool ableToMove = true;



			int xIncrementer=0;
			int yIncrementer=0;
			int incrementsNeededToCheck = 0;

			if(vector[0]>0){
				xIncrementer=1;
			}else if(vector[0]<0){
				xIncrementer=-1;
			}else{
				xIncrementer=0;
			}
			if(vector[1]>0){
				yIncrementer = -1;
			}else if(vector[1]<0){
				yIncrementer=1;
			}else{
				yIncrementer=0;
			}	

			if(Math.Abs(endCoordinates[0]-startCoordinates[0])>Math.Abs(endCoordinates[1]-startCoordinates[1])){
				incrementsNeededToCheck=Math.Abs(endCoordinates[0]-startCoordinates[0]);
			}else{
				incrementsNeededToCheck=Math.Abs(endCoordinates[1]-startCoordinates[1]);
			}

			
			int X = startCoordinates[0];
			int Y = startCoordinates[1];
			for(int i=0; i< incrementsNeededToCheck;i++){
				X += xIncrementer;
				Y += yIncrementer;
				
				// ensure values in grid()
				if(X<0 || X>7 || Y<0 || Y>7){
					ableToMove=false;
					break;
				}
				
				if(grid[X,Y]!=null){
					System.Diagnostics.Debug.WriteLine("Stuff in WAY!");
					ableToMove=false;
					break;
				}
			}

			return ableToMove;
		}

		// to move the piece once verified
		// input: start, and end coordinates
		// output: void
		public void movePiece(int startX, int startY, int endX, int endY){
			grid[endX,endY] = grid[startX,startY];
			grid[endX,endY].setMoved();

			grid[startX,startY] = null;
		}


		// To take a coordinate input and turn into something readable
		// Returns an array where val[0]=x, val[1]=y
		// Depreciated. Morgan will be parsing inputs
		public int[] getFormattedCoordinate(string coordinate){
			int[] returnable = new int[2];

			string XRaw;
			string YRaw;

			XRaw = coordinate[1].ToString();
			YRaw = coordinate[0].ToString();

			int XFinal=0;
			int YFinal=0;


			switch(YRaw){
				case "A":
					YFinal = 1;
					break;
				case "B":
					YFinal = 2;
					break;
				case "C":
					YFinal = 3;
					break;
				case "D":
					YFinal = 4;
					break;
				case "E":
					YFinal = 5;
					break;
				case "F":
					YFinal = 6;
					break;
				case "G":
					YFinal = 7;
					break;
				case "H":
					YFinal = 8;
					break;
				default:
					System.Diagnostics.Debug.WriteLine("Invalid move was given");
					break;

			}
			XFinal = Int32.Parse(XRaw);

			// We need to subtract by 1 for the matrix locations
			returnable[0] = XFinal-1;
			returnable[1] = YFinal-1;

			return returnable;

		}

		public void printNodes(){

			int ASCIIA = 64;

			for(int k=-1; k< grid.GetLength(0);k++){
				for(int j=-1; j < grid.GetLength(1);j++){
					if (k==-1){
						if(j==-1){
							//output+= " |           | ";
							System.Diagnostics.Debug.Write(" |           | ");
						}else{	
							//output+=" |    "+(char)ASCIIA+"     | ";
							System.Diagnostics.Debug.Write(" |    "+(char)ASCIIA+"     | ");
						}
						ASCIIA++;

					}else{
						if(j ==-1 && k ==-1){
							System.Diagnostics.Debug.Write(" |          | ");
							
						}else if(j==-1){
							System.Diagnostics.Debug.Write(" |     "+(k+1)+"     | ");
						}else{
							if(grid[k,j] ==null){
								//output+=" |          | ";
								System.Diagnostics.Debug.Write(" |          | ");
							}else{
								string spacer = grid[k,j].getName();
								int spacerIndex = 0;
								spacerIndex = 10 - grid[k,j].getName().Length;
								for(int i=0; i< spacerIndex; i++){
									spacer+=" ";
								}
								//output+= " |"+spacer+"| ";
								System.Diagnostics.Debug.Write(" |");
								string team = grid[k,j].getTeamName();
								if(team=="Team1"){
									System.Diagnostics.Debug.ForegroundColor = ConsoleColor.Blue;
								}else{
									System.Diagnostics.Debug.ForegroundColor = ConsoleColor.Red;
								}
								System.Diagnostics.Debug.Write(spacer);
								System.Diagnostics.Debug.ResetColor();
								System.Diagnostics.Debug.Write("| ");
							}
						}

					}
				}
				//System.Diagnostics.Debug.WriteLine(output);
				System.Diagnostics.Debug.Write("\n");
			}
		}

		

		


	}





	

}

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Chess.Pieces;
using WizardsChess.Movement;

namespace WizardsChess.Chess
{
	public interface IChessBoard
	{
		ChessPiece PieceAt(int x, int y);
		ChessPiece PieceAt(Point2D location);
		ChessPiece PieceAt(Position location);
		int NumCapturedPieces(ChessTeam team);
		Dictionary<PieceType, IList<Point2D>> PieceLocationsByType { get; }
		IDictionary<ChessTeam, IList<ChessPiece>> CapturedPiecesByTeam { get; }
		IList<MoveSpecification> PastMoves { get; }
		int GetWhiteBackRow();
		int GetWhiteFrontRow();
		int GetBlackBackRow();
		int GetBlackFrontRow();
		int GetLeftRookCol();
		int GetLeftKnightCol();
		int GetLeftBishopCol();
		int GetKingCol();
		int GetQueenCol();
		int GetRightBishopCol();
		int GetRightKnightCol();
		int GetRightRookCol();
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Chess
{
	public class MoveSpecification
	{
		public MoveSpecification (Position s, Position e, Position? cap = null, bool hasMovedChange = false, bool cast = false)
		{
			Start = s;
			End = e;
			Capture = cap;
			HasMovedChange = hasMovedChange;
			Castle = cast;
		}
		/*
		public MoveSpecification Get()
		{
			return new MoveSpecification(start, end, capture);
		}
		public Position GetStart()
		{
			return start;
		}
		public Position GetEnd()
		{
			return end;
		}
		public Position? GetCapture()
		{
			return capture;
		}
		*/
		public Position Start;	//end position of the move
		public Position End;	//end position of the move
		public Position? Capture;   //true if this move involved capturing a piece
		public bool HasMovedChange;	//whether or not this move was that piece moving for the first time. Not updated on castling, but accounted for in castling undo
		public bool Castle;		//whether or not the move was a castle
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement;

namespace WizardsChess.Chess.Pieces
{
	class Bishop : ChessPiece
	{
		public Bishop(ChessTeam team) : base(team)
		{
			Type = PieceType.Bishop;
			if (allowedMotionVectors.Count == 0)
			{
				for (int move = 1; move <= ChessBoard.Size; move++)
				{
					allowedMotionVectors.Add(new Vector2D(move, move));
					allowedMotionVectors.Add(new Vector2D(move, -move));
					allowedMotionVectors.Add(new Vector2D(-move, move));
					allowedMotionVectors.Add(new Vector2D(-move, -move));
				}
			}
		}

		public override ChessPiece DeepCopy()
		{
			Bishop piece = new Bishop(this.Team);
			piece.HasMoved = this.HasMoved;
			piece.HasMoved = this.HasMoved;
			piece.CanJump = this.CanJump;
			return piece;
		}

		private static List<Vector2D> allowedMotionVectors = new List<Vector2D>();

		public override IReadOnlyList<Vector2D> GetAllowedMotionVectors()
		{
			return allowedMotionVectors;
		}

		public override IReadOnlyList<Vector2D> GetAttackMotionVectors()
		{
			return allowedMotionVectors;
		}
	}
}
using System;
using System.Collections;
using System.Collections.Generic;
using WizardsChess.Movement;

// Board arranged in A-H, 1-8. where A-H is replaced by 9-16
namespace WizardsChess.Chess.Pieces {
	public abstract class ChessPiece{

		public ChessPiece(ChessTeam team){
			Team = team;
			HasMoved = false;
			CanJump = false;
		}

		/*
		public ChessPiece(ChessPiece piece)
		{
			Type = piece.Type;
			Team = piece.Team;
			HasMoved = piece.HasMoved;
			CanJump = piece.CanJump;
		}
		*/

		public abstract ChessPiece DeepCopy();

		public PieceType Type { get; protected set; }

		public ChessTeam Team { get; }

		public bool HasMoved { get; set; }

		public bool CanJump { get; protected set; }

		public virtual string ToShortString()
		{
			return /*Team.ToString().Substring(0, 1) + "-" + */Type.ToString().Substring(0, 1);
		}

		public override string ToString()
		{
			return Team.ToString() + "-" + Type.ToString();
		}

		public abstract IReadOnlyList<Vector2D> GetAllowedMotionVectors();

		public abstract IReadOnlyList<Vector2D> GetAttackMotionVectors();
	}
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement;

namespace WizardsChess.Chess.Pieces
{
	abstract class DirectionalChessPiece : ChessPiece
	{
		public DirectionalChessPiece(ChessTeam team) : base(team)
		{
			switch (team)
			{
				case ChessTeam.White:
					ForwardDirection = WhiteForwardDirection;
					break;
				case ChessTeam.Black:
					ForwardDirection = BlackForwardDirection;
					break;
				default:
					// Default is impossible
					break;
			}
		}

		public Vector2D ForwardDirection { get; }

		protected static readonly Vector2D WhiteForwardDirection = new Vector2D(0, 1);
		protected static readonly Vector2D BlackForwardDirection = -WhiteForwardDirection;
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement;

namespace WizardsChess.Chess.Pieces
{
	class King : ChessPiece
	{
		public King(ChessTeam team) : base(team)
		{
			Type = PieceType.King;
		}

		public override ChessPiece DeepCopy()
		{
			King piece = new King(this.Team);
			piece.HasMoved = this.HasMoved;
			piece.HasMoved = this.HasMoved;
			piece.CanJump = this.CanJump;
			return piece;
		}

		private static IReadOnlyList<Vector2D> allowedMotionVectors = new List<Vector2D>()
		{
			new Vector2D(-1,-1),
			new Vector2D(-1, 0),
			new Vector2D(-1, 1),
			new Vector2D(0, -1),
			new Vector2D(0, 1),
			new Vector2D(1, -1),
			new Vector2D(1, 0),
			new Vector2D(1, 1)
		};

		public override IReadOnlyList<Vector2D> GetAllowedMotionVectors()
		{
			return allowedMotionVectors;
		}

		public override IReadOnlyList<Vector2D> GetAttackMotionVectors()
		{
			return allowedMotionVectors;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement;

namespace WizardsChess.Chess.Pieces
{
	class Knight : ChessPiece
	{
		public Knight(ChessTeam team) : base(team)
		{
			Type = PieceType.Knight;
			CanJump = true;
		}

		public override ChessPiece DeepCopy()
		{
			Knight piece = new Knight(this.Team);
			piece.HasMoved = this.HasMoved;
			piece.HasMoved = this.HasMoved;
			piece.CanJump = this.CanJump;
			return piece;
		}

		public static IReadOnlyList<Vector2D> allowedMotionVectors = new List<Vector2D>()
		{
			new Vector2D(-2, 1),
			new Vector2D(-2, -1),
			new Vector2D(2, 1),
			new Vector2D(2, -1),
			new Vector2D(1, 2),
			new Vector2D(1, -2),
			new Vector2D(-1, 2),
			new Vector2D(-1, -2)
		};

		public override string ToShortString()
		{
			{
				return "Kn";
			}
		}

		public override IReadOnlyList<Vector2D> GetAllowedMotionVectors()
		{
			return allowedMotionVectors;
		}

		public override IReadOnlyList<Vector2D> GetAttackMotionVectors()
		{
			return allowedMotionVectors;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement;

namespace WizardsChess.Chess.Pieces
{
	class Pawn : DirectionalChessPiece
	{
		public Pawn(ChessTeam team) : base(team)
		{
			Type = PieceType.Pawn;
		}

		public override ChessPiece DeepCopy()
		{
			Pawn piece = new Pawn(this.Team);
			piece.HasMoved = this.HasMoved;
			piece.HasMoved = this.HasMoved;
			piece.CanJump = this.CanJump;
			return piece;
		}

		// contains motions of allowed chess piece
		private static IReadOnlyList<Vector2D> allowedMotionVectors = new List<Vector2D>()
		{
			new Vector2D(0, 1)
		};
		// contains special motion vectors where additional check is required
		private static IReadOnlyList<Vector2D> specialMotionVectors = new List<Vector2D>()
		{
			new Vector2D(0, 2)
		};

		// contains attack motion vectors
		private static IReadOnlyList<Vector2D> attackMotionVectors = new List<Vector2D>()
		{
			new Vector2D(1, 1),
			new Vector2D(-1, 1)
		};

		public override IReadOnlyList<Vector2D> GetAllowedMotionVectors()
		{
			var allowedMoves = new List<Vector2D>(allowedMotionVectors);
			if (!HasMoved)
			{
				allowedMoves.AddRange(specialMotionVectors);
			}

			if (ForwardDirection == WhiteForwardDirection)
			{
				return allowedMoves;
			}
			else if (ForwardDirection == BlackForwardDirection)
			{
				return allowedMoves.Select(v => v.FlipY()).ToList();
			}
			else
			{
				throw new InvalidOperationException($"Tried to get allowed moves for {nameof(Pawn)} when ForwardDirection was {ForwardDirection}");
			}
		}

		public override IReadOnlyList<Vector2D> GetAttackMotionVectors()
		{
			if (ForwardDirection == WhiteForwardDirection)
			{
				return attackMotionVectors;
			}
			else if (ForwardDirection == BlackForwardDirection)
			{
				return attackMotionVectors.Select(v => v.FlipY()).ToList();
			}
			else
			{
				throw new InvalidOperationException($"Tried to get attack moves for {nameof(Pawn)} when ForwardDirection was {ForwardDirection}");
			}
		}

	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement;

namespace WizardsChess.Chess.Pieces
{
	class Queen : ChessPiece
	{
		public Queen(ChessTeam team) : base(team)
		{
			Type = PieceType.Queen;
			if (allowedMotionVectors.Count == 0)
			{
				for (int move = 1; move <= ChessBoard.Size; move++)
				{
					// Bishop moves
					allowedMotionVectors.Add(new Vector2D(move, move));
					allowedMotionVectors.Add(new Vector2D(move, -move));
					allowedMotionVectors.Add(new Vector2D(-move, move));
					allowedMotionVectors.Add(new Vector2D(-move, -move));
					// Rook moves
					allowedMotionVectors.Add(new Vector2D(move, 0));
					allowedMotionVectors.Add(new Vector2D(-move, 0));
					allowedMotionVectors.Add(new Vector2D(0, move));
					allowedMotionVectors.Add(new Vector2D(0, -move));
				}
			}
		}

		public override ChessPiece DeepCopy()
		{
			Queen piece = new Queen(this.Team);
			piece.HasMoved = this.HasMoved;
			piece.HasMoved = this.HasMoved;
			piece.CanJump = this.CanJump;
			return piece;
		}

		private static List<Vector2D> allowedMotionVectors = new List<Vector2D>();

		public override IReadOnlyList<Vector2D> GetAllowedMotionVectors()
		{
			return allowedMotionVectors;
		}

		public override IReadOnlyList<Vector2D> GetAttackMotionVectors()
		{
			return allowedMotionVectors;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement;

namespace WizardsChess.Chess.Pieces
{
	class Rook : ChessPiece
	{
		public Rook(ChessTeam team) : base(team)
		{
			Type = PieceType.Rook;

			if (allowedMotionVectors.Count == 0)
			{
				for (int move = 1; move <= ChessBoard.Size; move++)
				{
					allowedMotionVectors.Add(new Vector2D(move, 0));
					allowedMotionVectors.Add(new Vector2D(-move, 0));
					allowedMotionVectors.Add(new Vector2D(0, move));
					allowedMotionVectors.Add(new Vector2D(0, -move));
				}
			}
		}

		public override ChessPiece DeepCopy()
		{
			Rook piece = new Rook(this.Team);
			piece.HasMoved = this.HasMoved;
			piece.HasMoved = this.HasMoved;
			piece.CanJump = this.CanJump;
			return piece;
		}

		// contains motions of allowed chess piece
		private static List<Vector2D> allowedMotionVectors = new List<Vector2D>();

		public override IReadOnlyList<Vector2D> GetAllowedMotionVectors()
		{
			return allowedMotionVectors;
		}

		public override IReadOnlyList<Vector2D> GetAttackMotionVectors()
		{
			return allowedMotionVectors;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Chess
{
	public enum PieceType
	{
		King,
		Queen,
		Knight,
		Bishop,
		Rook,
		Pawn
	}

	public static class PieceTypeMethods
	{
		public static PieceType Parse(string pieceName)
		{
			if (pieceName.Equals("castle", StringComparison.OrdinalIgnoreCase))
			{
				return PieceType.Rook;
			}
			var piece = Enum.Parse(typeof(PieceType), pieceName, true) as PieceType?;
			if (piece == null)
			{
				throw new ArgumentException($"Could not convert string \"{pieceName}\" to a {nameof(PieceType)} enum.");
			}
			return piece.Value;
		}
	}
	
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement;

namespace WizardsChess.Chess
{
	public enum ColumnLetter
	{
		A = 0,
		B = 1,
		C = 2,
		D = 3,
		E = 4,
		F = 5,
		G = 6,
		H = 7
	}

	public struct Position
	{
		public Position(string posLetter, string posNumber)
		{
			ColumnLetter = (Enum.Parse(typeof(ColumnLetter), posLetter, true) as ColumnLetter?).Value;
			// Convert from 1-based indexing to zero-based indexing
			Row = Int32.Parse(posNumber) - 1;
		}

		public Position(Point2D pos)
		{
			Row = pos.Y;
			ColumnLetter = (ColumnLetter)pos.X;
		}

		public Position(Position pos)
		{
			Row = pos.Row;
			ColumnLetter = pos.ColumnLetter;
		}

		public Position(int column, int row)
		{
			Row = row;
			ColumnLetter = (ColumnLetter)column;
		}

		public ColumnLetter ColumnLetter { get; /*set;*/ }
		public int Row { get; /*set;*/ }
		public int Column
		{
			get { return (int)ColumnLetter; }
			//set { ColumnLetter = (ColumnLetter)value; }
		}

		public override string ToString() => $"{ColumnLetter}{Row + 1}";

		public override bool Equals(object obj)
		{
			if (obj is Position)
			{
				var p = (Position)obj;
				return p == this;
			}
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			return Column * 8 + Row;
		}

		public static bool operator ==(Position pLhs, Position pRhs) => pLhs.Column == pRhs.Column && pLhs.Row == pRhs.Row;
		public static bool operator !=(Position pLhs, Position pRhs) => !(pLhs == pRhs);

		public static implicit operator Point2D(Position p) => new Point2D(p.Column, p.Row);
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement.Drv.Events
{
	public enum GpioEdge
	{
		FallingEdge,
		RisingEdge
	}

	public class GpioValueChangedEventArgs : EventArgs
	{
		public GpioEdge Edge { get; }

		public GpioValueChangedEventArgs(GpioEdge e)
		{
			Edge = e;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement.Drv.Events
{
	public class MotorDirectionChangedEventArgs : EventArgs
	{
		public MoveDirection Direction { get; }
		public MotorDirectionChangedEventArgs(MoveDirection direction)
		{
			Direction = direction;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv.Events;

namespace WizardsChess.Movement.Drv
{
	public enum GpioValue
	{
		Low,
		High
	}

	public interface IGpioPin
	{
		event GpioValueChangedEventHandler ValueChanged;

		int PinNum { get; }

		GpioValue Read();

		void Write(GpioValue val);
	}

	public delegate void GpioValueChangedEventHandler(object sender, GpioValueChangedEventArgs e);
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement.Drv
{
	public interface IMagnetDrv
	{
		void TurnOn();

		void TurnOff();

		bool IsOn { get; }
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement.Drv
{
	public interface IMotorDrv
	{
		IMotorInformation Information { get; }

		MoveDirection Direction { get; set; }
		MoveDirection PreviousDirection { get; }

		// TODO: remove?
		/// <summary>
		/// Returns the most-recent move that was not Stopped.
		/// </summary>
		/// <returns></returns>
		MoveDirection GetLatestActiveMoveDirection();
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv.Events;

namespace WizardsChess.Movement.Drv
{
	public interface IMotorInformation
	{
		IGpioPin SteppingPin { get; }
		MoveDirection Direction { get; }
		Axis Axis { get; }
		event MotorDirectionChangedEventHandler DirectionChanged;
	}

	public delegate void MotorDirectionChangedEventHandler(object sender, MotorDirectionChangedEventArgs e);
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv.Events;

namespace WizardsChess.Movement.Drv
{
	public interface IPhotoInterrupter : IGpioPin
	{
		/// <summary>
		/// The grid position this interrupter is located, as defined by the physical setup.
		/// </summary>
		int GridPosition { get; }

		/// <summary>
		/// The step position we should expect to find the interrupter, as defined by calibration.
		/// </summary>
		int StepPosition { get; set; }
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv.Events;

namespace WizardsChess.Movement.Drv
{
	public class MotorInformation : IMotorInformation, IDisposable
	{
		public MotorInformation(Axis axis, IGpioPin motorStepPin)
		{
			SteppingPin = motorStepPin;
			SteppingPin.ValueChanged += pinValueChanged;
			Axis = axis;
			Direction = MoveDirection.Stopped;

			stepTimer = new Timer(timerTickCallback, null, Timeout.Infinite, Timeout.Infinite);
		}

		public Axis Axis { get; }
		public MoveDirection Direction
		{
			get { return direction; }

			private set
			{
				if (direction != value)
				{
					direction = value;
					DirectionChanged?.Invoke(this, new MotorDirectionChangedEventArgs(direction));
				}
			}
		}
		public IGpioPin SteppingPin { get; }

		public event MotorDirectionChangedEventHandler DirectionChanged;

		public void SetDirection(MoveDirection dir)
		{
			Direction = dir;
			if (dir != MoveDirection.Stopped)
			{
				ticksSinceLastStep = 0;
				stepTimer.Change(0, 15);
			}
		}

		private Timer stepTimer;
		private volatile MoveDirection direction;
		private volatile int ticksSinceLastStep;
		private const int MAX_TICKS_BETWEEN_STEPS = 5;


		private void pinValueChanged(object sender, GpioValueChangedEventArgs e)
		{
			ticksSinceLastStep = 0;
			if (Direction == MoveDirection.Stopped)
			{
				System.Diagnostics.Debug.WriteLine("${Axis} motor moved when in Stopped State!");
			}
		}

		private void timerTickCallback(object state)
		{
			// Check this class hasn't been disposed
			if (disposedValue)
			{
				return;
			}

			ticksSinceLastStep++;
			if (ticksSinceLastStep > MAX_TICKS_BETWEEN_STEPS)
			{
				Direction = MoveDirection.Stopped;
				stepTimer.Change(Timeout.Infinite, Timeout.Infinite);
			}
		}

		#region IDisposable Support
		private bool disposedValue = false; // To detect redundant calls

		protected virtual void Dispose(bool disposing)
		{
			if (!disposedValue)
			{
				if (disposing)
				{
					stepTimer.Dispose();
					SteppingPin.ValueChanged -= pinValueChanged;
				}

				disposedValue = true;
			}
		}

		// This code added to correctly implement the disposable pattern.
		public void Dispose()
		{
			// Do not change this code. Put cleanup code in Dispose(bool disposing) above.
			Dispose(true);
		}
		#endregion
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement.Events
{
	public class PositionChangedEventArgs : EventArgs
	{
		public int Position { get; }
		public MoveDirection Direction { get; }

		public PositionChangedEventArgs(int pos, MoveDirection direction)
		{
			Position = pos;
			Direction = direction;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement.Drv.Events
{
	public class StepEventArgs : EventArgs
	{
		public int NumSteps { get; set; }

		public StepEventArgs(int numSteps) : base()
		{
			NumSteps = numSteps;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement.Exceptions
{
	public class CalibrationException : Exception
	{
		public CalibrationException() : base() { }
		public CalibrationException(string message) : base(message) { }
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement
{
	public class GridMotorMover : IGridMotorMover
	{
		public GridMotorMover(IPreciseMotorMover preciseMover)
		{
			mover = preciseMover;
		}

		public int GridPosition { get; private set; }

		public async Task GoToPositionAsync(int gridPos)
		{
			// Update GridPositin first in case the move throws a CalibrationException afterwards
			GridPosition = gridPos;
			await mover.GoToPositionAsync(convertGridUnitsToStepPosition(gridPos));
		}

		public async Task CalibrateAsync()
		{
			await mover.CalibrateAsync();
		}

		private IPreciseMotorMover mover;

		private int convertGridUnitsToStepPosition(int gridPos)
		{
			return (int)Math.Round((float)gridPos * mover.StepsPerGridUnit);
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement
{
	public interface IGridMotorMover
	{
		int GridPosition { get; }
		Task GoToPositionAsync(int gridPos);
		Task CalibrateAsync();
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement
{
	public interface IMoveManager
	{
		/// <summary>
		/// Perform a chess move.
		/// </summary>
		/// <param name="start">The current location of the piece to be moved.</param>
		/// <param name="end">The destination for the chess piece.</param>
		/// <param name="captured">The location of the piece being captured, if different from 'end'.</param>
		Task MoveAsync(Point2D start, Point2D end, Point2D? captured=null);
		Task CastleAsync(Point2D rookSpot, int kingCol);
		Task UndoMoveAsync();
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement
{
	public interface IMovePerformer
	{
		Task MovePieceAsync(IList<Point2D> steps);
		Task MoveMotorAsync(Axis axis, int gridUnits);
		Task GoHomeAsync();
		Task CalibrateAsync();
		void EnableMagnet(bool enable);
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement
{
	public interface IMovePlanner
	{
		/// <summary>
		/// Provides movement paths for preforming en passant moves.
		/// All input positions are given in ChessBoard logical units.
		/// Output positions are in movement logical units.
		/// </summary>
		/// <param name="start">The current location of the piece to be moved.</param>
		/// <param name="end">The destination for the chess piece.</param>
		/// <param name="captured">The location of the piece being captured, if different from 'end'.</param>
		/// <returns>
		/// A list of List<Point2D>s. Each List<Point2D> indicates a piece move from start to finish.
		/// Point2Ds are in movement logical units (between ChessBoard units and motor step units).
		/// </returns>
		List<IList<Point2D>> PlanMove(Point2D start, Point2D end, Point2D? captured=null);
		List<IList<Point2D>> PlanCastle(Point2D rookStart, int kingCol);
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement
{
	public enum Axis
	{
		X,
		Y
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement
{
	public enum CalibrationState
	{
		Ready,
		NeedsCalibrating,
		PreparingToCalibrate,
		Calibrating
	}

	public interface IMotorCalibrator
	{
		float StepsPerGridUnit { get; }
		CalibrationState State { get; }

		Task CalibrateAsync();
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Events;

namespace WizardsChess.Movement
{
	public interface IMotorLocator
	{
		int Position { get; }
		MoveDirection LastMoveDirection { get; }

		void ShiftPosition(int shift);

		event PositionChangedEventHandler PositionChanged;
	}

	public delegate void PositionChangedEventHandler(object sender, PositionChangedEventArgs e);
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement
{
	public interface IMotorMover
	{
		/// <summary>
		/// How many steps the motor tends to keep moving for after being told to stop.
		/// </summary>
		int EstimatedOvershoot { get; }

		/// <summary>
		/// The IMotorLocator for this motor.
		/// </summary>
		IMotorLocator Locator { get; }

		/// <summary>
		/// Drive the motor up to the given position, then stop. 
		/// Does not return until the motor is completely stopped.
		/// </summary>
		/// <param name="position">The target position to drive the motor to. Not necessarily where the motor stops.</param>
		/// <returns>The position when the motor stops.</returns>
		Task<int> GoToPositionAsync(int position);

		/// <summary>
		/// Cancel an in-progress move.
		/// </summary>
		void CancelMove();
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv.Events;

namespace WizardsChess.Movement
{
	public interface IPositionSignaler
	{
		int Position { get; }

		void SignalOnPosition(int numSteps);
		void CancelSignal();

		event PositionChangedEventHandler ReachedPosition;
	}

	public delegate void StepEventHandler(Object sender, StepEventArgs e);
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement
{
	public interface IPreciseMotorMover
	{
		int Position { get; }
		float StepsPerGridUnit { get; }
		Task GoToPositionAsync(int position);
		Task CalibrateAsync();
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv;
using WizardsChess.Movement.Drv.Events;

namespace WizardsChess.Movement
{
	public class MotorCalibrator : IMotorCalibrator, IDisposable
	{
		public MotorCalibrator(int gridMinValue, int gridMaxValue
			, IMotorMover motorMover, IMotorInformation motorInformation
			, IPhotoInterrupter topInterrupter, IPhotoInterrupter bottomInterrupter)
		{
			gridMin = gridMinValue;
			gridMax = gridMaxValue;

			locator = motorMover.Locator;
			mover = motorMover;
			motorInfo = motorInformation;
			top = topInterrupter;
			bottom = bottomInterrupter;

			top.ValueChanged += topInterruptDetected;
			bottom.ValueChanged += bottomInterruptDetected;

			// Estimate the steps per grid unit
			StepsPerGridUnit = (float)(top.StepPosition - bottom.StepPosition) / (top.GridPosition - bottom.GridPosition);
			State = CalibrationState.NeedsCalibrating;
		}

		public float StepsPerGridUnit { get; private set; }
		public CalibrationState State { get; private set; }

		public async Task CalibrateAsync()
		{
			State = CalibrationState.PreparingToCalibrate;
			clearUpperAndLowerPos();

			var maxMoveDistance = convertGridUnitToSteps(gridMax - gridMin);
			var finalPos = await mover.GoToPositionAsync(locator.Position + maxMoveDistance / 2);

			if (hasAllPositionEstimates())
			{
				await calibrateFirstAndSecondPassAsync();
				return;
			}

			await mover.GoToPositionAsync(locator.Position - maxMoveDistance);

			await calibrateFirstAndSecondPassAsync();
		}

		private int gridMin;
		private int gridMax;

		private IMotorMover mover;
		private IMotorLocator locator;
		private IMotorInformation motorInfo;
		private IPhotoInterrupter top;
		private IPhotoInterrupter bottom;

		private int? upperTopPos;
		private int? lowerTopPos;
		private int? upperBottomPos;
		private int? lowerBottomPos;

		private int convertGridUnitToSteps(int gridUnit)
		{
			return (int)Math.Round(gridUnit * StepsPerGridUnit);
		}

		private int convertStepsToGridUnit(int steps)
		{
			return (int)Math.Round((float)steps / StepsPerGridUnit);
		}

		private void clearUpperAndLowerPos()
		{
			upperTopPos = null;
			lowerTopPos = null;
			upperBottomPos = null;
			lowerBottomPos = null;
		}

		private bool hasAllPositionEstimates()
		{
			return upperTopPos.HasValue && lowerTopPos.HasValue && upperBottomPos.HasValue && lowerBottomPos.HasValue;
		}

		private void updateStepsPerGridUnit()
		{
			StepsPerGridUnit = (float)(top.StepPosition - bottom.StepPosition) / (top.GridPosition - bottom.GridPosition);
		}

		private async Task calibrateFirstAndSecondPassAsync()
		{
			calibrateFirstPass();

			var distToMove = (top.StepPosition - bottom.StepPosition) + mover.EstimatedOvershoot * 2;
			if (locator.Position > top.StepPosition)
			{
				// Move down for second pass
				await mover.GoToPositionAsync(locator.Position - distToMove);
			}
			else
			{
				// Move up for second pass
				await mover.GoToPositionAsync(locator.Position + distToMove);
			}

			calibrateSecondPass();

			State = CalibrationState.Ready;
		}

		private void calibrateFirstPass()
		{ 
			var topPos = (upperTopPos.Value + lowerTopPos.Value) / 2;
			var bottomPos = (upperBottomPos.Value + lowerBottomPos.Value) / 2;
			var originPos = (topPos + bottomPos) / 2;

			locator.ShiftPosition(-originPos);
			top.StepPosition = topPos - originPos;
			bottom.StepPosition = bottomPos - originPos;
			updateStepsPerGridUnit();
		}

		private void calibrateSecondPass()
		{
			var topPos = (upperTopPos.Value + lowerTopPos.Value) / 2;
			var bottomPos = (upperBottomPos.Value + lowerBottomPos.Value) / 2;
			var originPos = (topPos + bottomPos) / 2;

			// Shift by half the offset to average with the first pass
			locator.ShiftPosition(-originPos / 2);
			top.StepPosition += (topPos - originPos);
			bottom.StepPosition += (bottomPos - originPos);
			top.StepPosition /= 2;
			bottom.StepPosition /= 2;
			updateStepsPerGridUnit();
		}

		private void topInterruptDetected(object sender, GpioValueChangedEventArgs e)
		{
			var pos = locator.Position;
			switch (State)
			{
				case CalibrationState.PreparingToCalibrate:
					// Check if can enter the Calibrating state
					if (e.Edge == GpioEdge.FallingEdge)
					{
						if (motorInfo.Direction == MoveDirection.Backward)
						{
							State = CalibrationState.Calibrating;
							upperTopPos = pos;
						}
					}
					else
					{
						if (motorInfo.Direction == MoveDirection.Forward)
						{
							mover.CancelMove();
						}
					}
					break;
				case CalibrationState.Calibrating:
					// Update nullable positions
					if (e.Edge == GpioEdge.FallingEdge)
					{
						if (motorInfo.Direction == MoveDirection.Backward)
						{
							upperTopPos = pos;
						}
						else
						{
							lowerTopPos = pos;
						}
					}
					else
					{
						if (motorInfo.Direction == MoveDirection.Forward)
						{
							upperTopPos = pos;
							mover.CancelMove();
						}
						else
						{
							lowerTopPos = pos;
						}
					}
					break;
				case CalibrationState.Ready:
					// Check we're still calibrated
					var offset = Math.Abs(pos - top.StepPosition);
					var tolerance = (upperTopPos.Value - lowerTopPos.Value) / 2 + 0.25 * StepsPerGridUnit;
					if (offset > tolerance)
					{
						System.Diagnostics.Debug.WriteLine($"Need to calibrate {motorInfo.Axis} motor.");
						State = CalibrationState.NeedsCalibrating;
					}
					break;
			}
		}

		private void bottomInterruptDetected(object sender, GpioValueChangedEventArgs e)
		{
			var pos = locator.Position;
			switch (State)
			{
				case CalibrationState.PreparingToCalibrate:
					// Check if can enter the Calibrating state
					if (e.Edge == GpioEdge.FallingEdge)
					{
						if (motorInfo.Direction == MoveDirection.Forward)
						{
							State = CalibrationState.Calibrating;
							lowerBottomPos = pos;
						}
					}
					else
					{
						if (motorInfo.Direction == MoveDirection.Backward)
						{
							mover.CancelMove();
						}
					}
					break;
				case CalibrationState.Calibrating:
					// Update nullable positions
					if (e.Edge == GpioEdge.FallingEdge)
					{
						if (motorInfo.Direction == MoveDirection.Forward)
						{
							lowerBottomPos = pos;
						}
						else
						{
							upperBottomPos = pos;
						}
					}
					else
					{
						if (motorInfo.Direction == MoveDirection.Backward)
						{
							lowerBottomPos = pos;
							mover.CancelMove();
						}
						else
						{
							upperBottomPos = pos;
						}
					}
					break;
				case CalibrationState.Ready:
					// Check we're still calibrated
					var offset = Math.Abs(pos - bottom.StepPosition);
					var tolerance = (upperBottomPos.Value - lowerBottomPos.Value) / 2 + 0.25 * StepsPerGridUnit;
					if (offset > tolerance)
					{
						System.Diagnostics.Debug.WriteLine($"Need to calibrate {motorInfo.Axis} motor.");
						State = CalibrationState.NeedsCalibrating;
					}
					break;
			}
		}

		#region IDisposable Support
		private bool disposedValue = false; // To detect redundant calls

		protected virtual void Dispose(bool disposing)
		{
			if (!disposedValue)
			{
				if (disposing)
				{
					top.ValueChanged -= topInterruptDetected;
					bottom.ValueChanged -= bottomInterruptDetected;
				}

				disposedValue = true;
			}
		}

		// This code added to correctly implement the disposable pattern.
		public void Dispose()
		{
			// Do not change this code. Put cleanup code in Dispose(bool disposing) above.
			Dispose(true);
		}
		#endregion
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv;
using WizardsChess.Movement.Drv.Events;
using WizardsChess.Movement.Events;

namespace WizardsChess.Movement
{
	public class MotorLocator : IMotorLocator, IDisposable
	{
		public MotorLocator(IGpioPin clearCounter, IMotorInformation motorInformation)
		{
			stepCounter = motorInformation.SteppingPin;
			clearCounterPin = clearCounter;
			motorInfo = motorInformation;
			position = 0;
			lastMoveDirection = MoveDirection.Stopped;

			stepCounter.ValueChanged += pinValueChanged;
		}

		public int Position { get { return position; } }
		public MoveDirection LastMoveDirection { get { return lastMoveDirection; } }

		public event PositionChangedEventHandler PositionChanged;

		public void ShiftPosition(int shift)
		{
			lock (lockObject)
			{
				// Doesn't affect lastMoveDirection because this is a calibration, not a real motor move.
				position += shift;
			}
		}

		private volatile int position;
		private volatile MoveDirection lastMoveDirection;
		private IGpioPin stepCounter;
		private IGpioPin clearCounterPin;
		private IMotorInformation motorInfo;
		private object lockObject = new object();

		private void pinValueChanged(object sender, GpioValueChangedEventArgs e)
		{
			if (e.Edge == GpioEdge.FallingEdge)
			{
				// If motor hasn't move and latestActiveMoveDirection is still Stopped, this will not impact anything because the Stopped value is 0.
				var pos = 0;
				var direction = motorInfo.Direction;
				lock (lockObject)
				{
					lastMoveDirection = direction;
					position += (int)direction;
					pos = position;
				}
				onStepCounted(pos, direction);
			}
		}

		private void onStepCounted(int pos, MoveDirection direction)
		{
			PositionChanged?.Invoke(this, new PositionChangedEventArgs(pos, direction));
		}

		#region IDisposable Support
		private bool disposedValue = false; // To detect redundant calls

		protected virtual void Dispose(bool disposing)
		{
			if (!disposedValue)
			{
				if (disposing)
				{
					stepCounter.ValueChanged -= pinValueChanged;
				}

				disposedValue = true;
			}
		}

		// This code added to correctly implement the disposable pattern.
		public void Dispose()
		{
			// Do not change this code. Put cleanup code in Dispose(bool disposing) above.
			Dispose(true);
		}
		#endregion
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv;
using WizardsChess.Movement.Drv.Events;
using WizardsChess.Movement.Events;

namespace WizardsChess.Movement
{
	enum MoverState
	{
		Ready,
		PerformingMove
	}

	public class MotorMover : IMotorMover, IDisposable
	{
		public MotorMover(int estimatedOvershoot, IPositionSignaler posSignaler, IMotorLocator motorLocator, IMotorDrv motorDrv)
		{
			EstimatedOvershoot = estimatedOvershoot;

			signaler = posSignaler;
			Locator = motorLocator;
			motor = motorDrv;

			signaler.ReachedPosition += finishedCounting;
			motor.Information.DirectionChanged += directionChanged;

			isMoving = false;
			state = MoverState.Ready;
			lockObject = new object();
		}

		public int EstimatedOvershoot { get; private set; }
		public IMotorLocator Locator { get; }

		public async Task<int> GoToPositionAsync(int position)
		{
			lock (lockObject)
			{
				if (state != MoverState.Ready)
				{
					System.Diagnostics.Debug.WriteLine($"{motor.Information.Axis} called GoToPositionAsync when in state {state}, resetting.");
					resetState();
				}
				state = MoverState.PerformingMove;
				targetPosition = position;
				shouldUpdateOvershoot = true;
			}
			await goToPositionAsync(position);
			lock (lockObject)
			{
				state = MoverState.Ready;
				if (shouldUpdateOvershoot)
				{
					updateEstimatedOvershoot(targetPosition);
				}
			}
			return Locator.Position;
		}

		public void CancelMove()
		{
			motor.Direction = MoveDirection.Stopped;

			lock (lockObject)
			{
				resetState();
				shouldUpdateOvershoot = false;
			}
		}

		private int targetPosition;
		private volatile bool isMoving;
		private volatile bool shouldUpdateOvershoot;
		private volatile MoverState state;
		private object lockObject;

		private IPositionSignaler signaler;
		private IMotorDrv motor;

		private void resetState()
		{
			state = MoverState.Ready;
			signaler.CancelSignal();
		}

		private void updateEstimatedOvershoot(int targetPosition)
		{
			EstimatedOvershoot += Math.Abs(targetPosition - Locator.Position);
			EstimatedOvershoot /= 2;
		}

		private async Task goToPositionAsync(int position)
		{
			if (isAtPosition(position))
			{
				return;
			}

			var offset = position - Locator.Position;
			if (offset == 0)
			{
				// We are now somehow at the desired position. 
				// Shouldn't happen, but we can return if it does.
				return;
			}

			lock (lockObject)
			{
				isMoving = true;
			}
			signaler.SignalOnPosition(position);
			if (offset < 0)
			{
				motor.Direction = MoveDirection.Backward;
			}
			else
			{
				motor.Direction = MoveDirection.Forward;
			}

			await waitForMoveToFinishAsync();
		}

		private async Task waitForMoveToFinishAsync()
		{
			bool shouldWait;
			lock (lockObject)
			{
				shouldWait = isMoving;
			}
			while (shouldWait)
			{
				await Task.Delay(45);
				lock (lockObject)
				{
					shouldWait = isMoving;
				}
			}
		}

		private bool isAtPosition(int position)
		{
			return position - Locator.Position == 0;
		}

		private void finishedCounting(object sender, PositionChangedEventArgs e)
		{
			motor.Direction = MoveDirection.Stopped;
			System.Diagnostics.Debug.WriteLine($"{motor.Information.Axis} motor finished counting.");
		}

		private void directionChanged(object sender, MotorDirectionChangedEventArgs e)
		{
			if (e.Direction == MoveDirection.Stopped)
			{
				if (motor.Direction != MoveDirection.Stopped)
				{
					// This is a stall!
					motor.Direction = MoveDirection.Stopped;
					lock (lockObject)
					{
						shouldUpdateOvershoot = false;
					}
					System.Diagnostics.Debug.WriteLine($"{motor.Information.Axis} motor stalled!");
				}
				lock (lockObject)
				{
					isMoving = false;
				}
				System.Diagnostics.Debug.WriteLine($"{motor.Information.Axis} motor has stopped.");
			}
		}

		#region IDisposable Support
		private bool disposedValue = false; // To detect redundant calls

		protected virtual void Dispose(bool disposing)
		{
			if (!disposedValue)
			{
				if (disposing)
				{
					signaler.ReachedPosition -= finishedCounting;
					motor.Information.DirectionChanged -= directionChanged;
				}

				disposedValue = true;
			}
		}

		// This code added to correctly implement the disposable pattern.
		public void Dispose()
		{
			// Do not change this code. Put cleanup code in Dispose(bool disposing) above.
			Dispose(true);
		}
		#endregion
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement
{
	public enum MoveDirection
	{
		Backward = -1,
		Stopped = 0,
		Forward = 1
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv.Events;
using WizardsChess.Movement.Events;

namespace WizardsChess.Movement
{
	enum CounterState
	{
		Ready,
		Counting
	}

	public class PositionSignaler : IDisposable, IPositionSignaler
	{
		public event PositionChangedEventHandler ReachedPosition;

		/// <summary>
		/// Signal specified position updates and extra steps.
		/// </summary>
		/// <param name="locator">The IMotorLocator maintaining motor position.</param>
		/// <param name="clearCounterPin">The pin used to clear the counter.</param>
		public PositionSignaler(IMotorLocator locator)
		{
			state = CounterState.Ready;

			motorLocator = locator;
			motorLocator.PositionChanged += positionChanged;
		}

		public int Position { get; private set; }

		public void SignalOnPosition(int position)
		{
			lock (lockObject)
			{
				targetPosition = position;
				if (targetPosition == motorLocator.Position)
				{
					onTargetReached();
					return;
				}

				state = CounterState.Counting;
			}
		}

		public void CancelSignal()
		{
			lock (lockObject)
			{
				state = CounterState.Ready;
			}
		}

		protected virtual void positionChanged(object locator, PositionChangedEventArgs args)
		{
			lock (lockObject)
			{
				if (state == CounterState.Counting)
				{
					if (args.Position == targetPosition
						|| (args.Direction == MoveDirection.Forward && args.Position > targetPosition)
						|| (args.Direction == MoveDirection.Backward && args.Position < targetPosition))
					{
						onTargetReached();
					}
				}
			}
		}

		private void onTargetReached()
		{
			state = CounterState.Ready;
			ReachedPosition?.Invoke(this, new PositionChangedEventArgs(motorLocator.Position, motorLocator.LastMoveDirection));
		}

		private volatile CounterState state;
		private IMotorLocator motorLocator;
		private int targetPosition;
		private object lockObject = new object();

		#region IDisposable Support
		private bool disposedValue = false; // To detect redundant calls

		protected virtual void Dispose(bool disposing)
		{
			if (!disposedValue)
			{
				if (disposing)
				{
					motorLocator.PositionChanged -= positionChanged;
				}

				disposedValue = true;
			}
		}

		// This code added to correctly implement the disposable pattern.
		public void Dispose()
		{
			// Do not change this code. Put cleanup code in Dispose(bool disposing) above.
			Dispose(true);
		}

		#endregion
	}
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Exceptions;

namespace WizardsChess.Movement
{
	public class PreciseMotorMover : IPreciseMotorMover
	{
		public PreciseMotorMover(IMotorMover motorMover, IMotorCalibrator motorCalibrator)
		{
			mover = motorMover;
			calibrator = motorCalibrator;
		}

		public int Position { get { return mover.Locator.Position; } }
		public float StepsPerGridUnit { get { return calibrator.StepsPerGridUnit; } }

		public async Task GoToPositionAsync(int position)
		{
			// Don't check for calibration at the start to allow us to force it if necessary
			await goToPositionAsync(position);
			// Run again to adjust for overshoot
			await goToPositionAsync(position);
			if (calibrator.State == CalibrationState.NeedsCalibrating)
			{
				throw new CalibrationException("Need to calibrate this motor after move.");
			}
		}

		public async Task CalibrateAsync()
		{
			await calibrator.CalibrateAsync();
		}

		private IMotorMover mover;
		private IMotorCalibrator calibrator;

		private async Task goToPositionAsync(int position)
		{
			if (isAtPosition(position))
			{
				return;
			}

			var drivePosition = calcDrivePosition(position);
			await mover.GoToPositionAsync(drivePosition);
		}

		private bool isAtPosition(int position)
		{
			var offset = mover.Locator.Position - position;
			return Math.Abs(offset) < 5;
		}

		private int calcDrivePosition(int position)
		{
			var requiredOffset = position - mover.Locator.Position;

			if (Math.Abs(requiredOffset) > mover.EstimatedOvershoot * 2)
			{
				var overshoot = requiredOffset > 0 ? mover.EstimatedOvershoot : -mover.EstimatedOvershoot;
				return requiredOffset - overshoot + mover.Locator.Position;
			}

			return requiredOffset / 2 + mover.Locator.Position;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Chess;
using WizardsChess.Movement.Drv;

namespace WizardsChess.Movement
{
	public class MoveManager : IMoveManager
	{
		public MoveManager(IMovePlanner movePlanner, IMovePerformer movePerformer)
		{
			planner = movePlanner;
			performer = movePerformer;
			previousMoves = new List<IList<IList<Point2D>>>();
		}

		public async Task MoveAsync(Point2D start, Point2D end, Point2D? captured = null)
		{
			var moveSteps = planner.PlanMove(start, end, captured);
			foreach (var setOfSteps in moveSteps)
			{
				await performer.MovePieceAsync(setOfSteps);
				//TODO: remove: previousMoves[previousMoves.Count - 1].Add(setOfSteps);
			}
			previousMoves.Add(moveSteps);
			await performer.GoHomeAsync();
		}

		public async Task CastleAsync(Point2D rookSpot, int kingCol)
		{
			var castleSteps = planner.PlanCastle(rookSpot, kingCol);
			foreach (var setOfSteps in castleSteps)
			{
				await performer.MovePieceAsync(setOfSteps);
				//TODO: remove: previousMoves[previousMoves.Count - 1].Add(setOfSteps);
			}
			previousMoves.Add(castleSteps);
			await performer.GoHomeAsync();
		}

		public async Task UndoMoveAsync()
		{
			//TODO: fix this
			if (previousMoves.Count > 0) {
				var lastMove = previousMoves[previousMoves.Count - 1];
				lastMove.Reverse();
				foreach (var setOfSteps in lastMove)
				{
					setOfSteps.Reverse();	//not reversing
					await performer.MovePieceAsync(setOfSteps);
				}
				previousMoves.RemoveAt(previousMoves.Count - 1);
			}
			else
			{
				System.Diagnostics.Debug.WriteLine($"No previous moves to do the reverse moves of.");
			}
		}

		private IMovePlanner planner;
		private IMovePerformer performer;
		private IList<IList<IList<Point2D>>> previousMoves;
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv;
using WizardsChess.Movement.Drv.Events;
using WizardsChess.Movement.Exceptions;

namespace WizardsChess.Movement
{
	public class MovePerformer : IMovePerformer
	{
		public MovePerformer(IGridMotorMover xMtrMover, IGridMotorMover yMtrMover, IMagnetDrv magnetDrv)
		{
			xMover = xMtrMover;
			yMover = yMtrMover;
			magnet = magnetDrv;
		}

		public async Task MovePieceAsync(IList<Point2D> steps)
		{
			if (steps.Count <= 1)
			{
				System.Diagnostics.Debug.WriteLine($"MovePerformer received a piece move list with only {steps.Count} move(s).");
				return;
			}

			var start = steps[0];
			steps.RemoveAt(0);

			System.Diagnostics.Debug.WriteLine($"MovePerformer sending move {start}");
			await tryToMoveAsync(xMover, start.X);
			await tryToMoveAsync(yMover, start.Y);

			magnet.TurnOn();

			foreach(var point in steps)
			{
				System.Diagnostics.Debug.WriteLine($"MovePerformer sending move {point}");
				await tryToMoveAsync(xMover, point.X);
				await tryToMoveAsync(yMover, point.Y);
			}

			magnet.TurnOff();
		}

		public Task MoveMotorAsync(Axis axis, int gridUnits)
		{
			System.Diagnostics.Debug.WriteLine("MovePerformer can't perform direct grid moves.");
			return Task.FromResult(0);
		}

		public async Task GoHomeAsync()
		{
			await tryToMoveAsync(xMover, 0);
			await tryToMoveAsync(yMover, 0);
		}

		public async Task CalibrateAsync()
		{
			await xMover.CalibrateAsync();
			await yMover.CalibrateAsync();
			await GoHomeAsync();
		}

		public void EnableMagnet(bool enable)
		{
			if (enable)
			{
				magnet.TurnOn();
			}
			else
			{
				magnet.TurnOff();
			}
		}

		private IGridMotorMover xMover;
		private IGridMotorMover yMover;
		private IMagnetDrv magnet;

		private async Task tryToMoveAsync(IGridMotorMover mover, int desiredGridPosition)
		{
			var previousPosition = mover.GridPosition;
			try
			{
				await mover.GoToPositionAsync(desiredGridPosition);
			}
			catch (CalibrationException)
			{
				await calibrateAndRetry(mover, previousPosition, desiredGridPosition);
			}
		}

		private async Task calibrateAndRetry(IGridMotorMover mover, int previousPos, int desiredGridPos)
		{
			if (magnet.IsOn)
			{
				magnet.TurnOff();
			}
			await mover.CalibrateAsync();
			try
			{
				await mover.GoToPositionAsync(previousPos);
			}
			catch (CalibrationException)
			{
				System.Diagnostics.Debug.WriteLine("Threw another CalibrationException on move despite recalibrating.");
			}

			if (magnet.IsOn)
			{
				magnet.TurnOn();
			}
			try
			{
				await mover.GoToPositionAsync(desiredGridPos);
			}
			catch(CalibrationException)
			{
				System.Diagnostics.Debug.WriteLine("Threw another CalibrationException on move despite recalibrating.");
			}
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Movement.Drv;
using WizardsChess.Movement.Drv.Events;

namespace WizardsChess.Movement
{
	public class MovePerformerVisualizer : IMovePerformer
	{

		public MovePerformerVisualizer()
		{
			BoardRep = new char[ySize, xSize];
		}

		public Task MovePieceAsync(IList<Point2D> steps)
		{
			Point2D convertedPoint;
			int i = 1;

			ResetBoardRep();

			foreach (var point in steps)
			{
				convertedPoint = ConvertPoint(point);
				BoardRep[convertedPoint.Y, convertedPoint.X] = i.ToString()[0];
				i++;
			}

			PrintBoardRep();

			return Task.FromResult(0);
		}

		public void ResetBoardRep()
		{
			for (int j = 0; j < ySize; j++)
			{
				for (int i = 0; i < xSize; i++)
				{
					if ((j > 0 && j < ySize - 1) && (i == 0 || i == xSize - 1))
						BoardRep[j, i] = 'o';
					else if ((j > 0 && j < ySize - 1) && (i == emptyCol1 || i == emptyCol2))
						BoardRep[j, i] = 'x';
					else if (i % 2 == 0 && j % 2 == 1 && i != 0 && i != xSize - 1)
						BoardRep[j, i] = ' ';
					else if (i % 2 == 1 && j % 2 == 0)
						BoardRep[j, i] = '+';
					else if (i % 2 == 1)
						BoardRep[j, i] = '|';
					else
						BoardRep[j, i] = '-';
				}
			}
		}

		public void PrintBoardRep()
		{
			for (int j = 0; j < ySize; j++)
			{
				for (int i = 0; i < xSize; i++)
				{
					System.Diagnostics.Debug.Write(BoardRep[ySize - 1 - j, i]);
				}
				System.Diagnostics.Debug.WriteLine("");
			}
		}

		//converts input Points to Matrix indicies;
		public Point2D ConvertPoint(Point2D point)
		{
			return new Point2D(ConvertX(point.X), ConvertY(point.Y));
		}
		//converts (-11_11 to 0_23)
		public int ConvertX(int x)
		{
			return x + xOffset;
		}
		//convert (-8_8 to 0_16)
		public int ConvertY(int y)
		{
			return y + yOffset;
		}

		public Task GoHomeAsync()
		{
			return Task.FromResult(0);
		}

		public Task CalibrateAsync()
		{
			return Task.FromResult(0);
		}

		public void EnableMagnet(bool enable) {	}	//unneeded

		public Task MoveMotorAsync(Axis axis, int gridUnits)	{ return Task.FromResult(0); }	//unneeded

		public char[,] BoardRep;
		const int xSize = 23;
		const int ySize = 17;
		int emptyCol1 = 2;
		int emptyCol2 = 20;
		const int xOffset = (xSize - 1)/2;	//number added to input Point2D's to get boardMatrix index (-11_11 to 0_23)
		const int yOffset = (ySize - 1)/2;	//(-8_8 to 0_16)

	}
}
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Chess;

namespace WizardsChess.Movement
{
    public class MovePlanner : IMovePlanner
    {
        public MovePlanner (IChessBoard b)
        {
            board = b;
        }

        public List<IList<Point2D>> PlanMove(Point2D start, Point2D end, Point2D? captured=null)	//inputs (0-7, 0-7)
        {
            List<IList<Point2D>> paths = new List<IList<Point2D>>();
            
			if (captured.HasValue)
			{
				paths.Add(getCapturedPath(end));
			}
			if (captured != end && board.PieceAt(end) != null)
			{
				paths.Add(getCapturedPath(end));
			}
			paths.Add(getMovePath(start, end));

			return paths;
        }

		//castles, moving the king over two squares, and moving the rook around it
		public List<IList<Point2D>> PlanCastle(Point2D rookStart, int kingCol)	//rookPoint is the point in (0-7,0-7) form
		{
			List<IList<Point2D>> castlePaths = new List<IList<Point2D>>();

			int rookDir = Math.Sign(rookStart.X - kingCol);	//direction from King to Rook

			//get King Movement
			Point2D kingStartPoint = pointConversion(new Point2D(kingCol, rookStart.Y));
			Point2D kingEndPoint = kingStartPoint + new Vector2D(2 * spacing * rookDir, 0);	//the king moves 2 squares towards the rook
			castlePaths.Add(getStraightMovePath(kingStartPoint, kingEndPoint));

			castlePaths.Add(getCastlingRookPath(pointConversion(rookStart), rookDir, xConversion(kingCol)));  //get Rook Movement- must convert rookStart and kingCol, but rookDir is just a direction and constant

			return castlePaths;
		}

		//Point Conversions from (0-7,0-7) to (-11 to 11, -8 to 8) done here
        private List<Point2D> getMovePath(Point2D start, Point2D end)
        {
            Point2D startPoint = pointConversion(start);
            Point2D endPoint = pointConversion(end);

			//could check for null here, if unsure if that check isn't done elsewhere
			if (board.PieceAt(start).CanJump)
			{
				return getKnightMovePath(startPoint, endPoint);
			}
			else if (start.X != end.X && start.Y != end.Y)	//diagonal movement, could be removed if diagonal movement of the motors is achived
			{
				return getDiagonalMovePath(startPoint, endPoint);
			}
			else //piece moving is a non knight piece
			{
				return getStraightMovePath(startPoint, endPoint);
			}
        }

        //gets the path of movement for knight piece moves
        //path[path.Count - 1].X or Y is just a way of saying the previous value for X or Y in the path
        private List<Point2D> getKnightMovePath(Point2D startPoint, Point2D endPoint)
        {
            List<Point2D> path = new List<Point2D>();

            int xMove = endPoint.X - startPoint.X; //number of squares moving should both be -4, -2, 2, or 4
            int yMove = endPoint.Y - startPoint.Y;
            int xVsY = Math.Abs(xMove) - Math.Abs(yMove);   //should be -2 or 2

            path.Add(startPoint);
            if (xVsY > 0)  //moving further in the x direction, xVsY should equal 2
            {
                path.Add(new Point2D(startPoint.X, startPoint.Y + yMove/2));
                path.Add(new Point2D(endPoint.X, path[path.Count - 1].Y));
            }
            else   //moving further in the y direction, xVsY should equal -2
            {
                path.Add(new Point2D(startPoint.X + xMove/2, startPoint.Y));
                path.Add(new Point2D(path[path.Count - 1].X, endPoint.Y));
            }
            path.Add(endPoint);

            return path;
        }

		private List<Point2D> getDiagonalMovePath(Point2D startPoint, Point2D endPoint)
		{
			List<Point2D> path = new List<Point2D>();
			int Dist = Math.Abs(endPoint.X - startPoint.X);	//number of points moving in each direction
			int xDir = Math.Sign(endPoint.X - startPoint.X);	//x-direction moving in the x direction
			int yDir = Math.Sign(endPoint.Y - startPoint.Y);	//y-direction of movement

			path.Add(startPoint);
			path.Add(new Point2D(startPoint.X + xDir, startPoint.Y));
			if (Dist > spacing)	//if moving more than 1 square diagonally, 4 part moves required
			{
				path.Add(new Point2D(path[path.Count - 1].X, endPoint.Y - yDir));
				path.Add(new Point2D(endPoint.X, path[path.Count - 1].Y));
			}
			else // Dist == spacing, only 3 part moves required
			{
				path.Add(new Point2D(path[path.Count - 1].X, endPoint.Y));
			}
			path.Add(endPoint);

			return path;
		}

		//gets the direct path of movement for non-knight piece moves (but not that of captured pieces)
		private List<Point2D> getStraightMovePath(Point2D startPoint, Point2D endPoint)
		{
			List<Point2D> path = new List<Point2D>();

			path.Add(startPoint);
			path.Add(endPoint);

			return path;
		}

		//gets the path of movement for a captured piece from the board to the trough
		//expects points to be in 23x17 form
		private List<Point2D> getCapturedPath(Point2D start) //change capturedTeam type
        {
            Point2D startPoint = pointConversion(start);
            ChessTeam team = board.PieceAt(start).Team; 
            int numCaptured = board.NumCapturedPieces(team);

            List<Point2D> path = new List<Point2D>();

            if (team == ChessTeam.White)
            {
                path = getCapturedPathWithTeam(startPoint, whiteRemovalDir, whiteEmptyCol, whiteCapturedCol, whiteCapturedStart + whiteCapturedAddDir * numCaptured);
			}
            else    //team == ChessTeam.Black
            {
                path = getCapturedPathWithTeam(startPoint, blackRemovalDir, blackEmptyCol, blackCapturedCol, blackCapturedStart + blackCapturedAddDir * numCaptured);
			}
            return path;
        }

        //path[path.Count - 1].X or Y is just a way of saying the previous value for X or Y in the path
        private List<Point2D> getCapturedPathWithTeam(Point2D startPoint, int dir, int emptyCol, int capturedCol, int troughIndex)
        {
            //the number of half squares from the edge of the board to put the first captured piece at
            List<Point2D> path = new List<Point2D>();

            path.Add(startPoint);
            path.Add(new Point2D(startPoint.X, startPoint.Y + dir));    //only needs to move half a square, so no multiplier needed on Dir
            if (path[path.Count - 1].Y != troughIndex) //only need to reposition in the empty column if it cannot go straight across
            {
                path.Add(new Point2D(emptyCol, path[path.Count - 1].Y));
                path.Add(new Point2D(path[path.Count - 1].X, troughIndex));
			}
            path.Add(new Point2D(capturedCol, troughIndex));
            return path;
        }

        private List<Point2D> getCastlingRookPath(Point2D rookStartPoint, int rookDir, int kingColIndex)	//expects converted (to large index) inputs 
		{
			List<Point2D> rookPath = new List<Point2D>();
			Point2D rookEndPoint = new Point2D(kingColIndex + spacing * rookDir, rookStartPoint.Y);	//the rook's final position is 1 square in its direction from the king's column
			rookPath.Add(rookStartPoint + new Vector2D(0, Math.Sign(rookStartPoint.Y) * castlingStepDir));  //assumes converted points use 0,0 as the centre of the board
			rookPath.Add(new Point2D(rookEndPoint.X, rookPath[rookPath.Count - 1].Y));
			rookPath.Add(rookEndPoint);
			return rookPath;
		}
		
		//converts from a (0-7,0-7) point to large coordinates (-11 to 11, -8 to 8) point
        private Point2D pointConversion(Point2D point)
        {
            return new Point2D(xConversion(point.X), yConversion(point.Y));
        }

		private int xConversion(int x)
		{
			return xOffset + spacing * x;
		}

		private int yConversion(int y)
		{
			return yOffset + spacing * y;
		}

        private IChessBoard board; 

		//constants getCapturedPath needs (in large coordinates)
		const int whiteEmptyCol = 9;     //index of the centre of the empty column in between the board and white captured pieces
        const int blackEmptyCol = -9;      //index of the centre of the empty column in between the board and black captured pieces
        const int whiteCapturedCol = 11;     //x-index of the centre of the column where white captured pieces are stored
        const int blackCapturedCol = -11;      //x-index of the centre of the column where black captured pieces are stored
        const int whiteCapturedStart = -7;    //y-index where the first white piece captured is placed
        const int blackCapturedStart = 7;   //y-index where the first black piece captured is placed
        const int whiteRemovalDir = -1;   //y-direction the white pieces are pulled a half square in before being captured off the board
        const int blackRemovalDir = 1;    //y-direction the black pieces are pulled a half square in before being captured off the board
        const int whiteCapturedAddDir = 1;   //y-direction white pieces are added to the white captured trough
        const int blackCapturedAddDir = -1;  //y-direction black pieces are added to the black captured trough

		//constants getCastlingRookPath needs
		const int castlingStepDir = 1;	//1 means away from the centre of the board, -1 means towards the centre of the board

		//constants pointConversion needs
		const int spacing = 2;    //number of points per square in one dimension
		const int xOffset = -7;    //x-index of the centre of the left most playing board column
		const int yOffset = -7;    //y-index of the centre of the bottom row
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Chess;

namespace WizardsChess.Movement
{
	// This is a value type, meaning it is passed by value, not by reference.
	// Because it is a small value, this is generally a good thing.
	// It is immutable to avoid confusion when updating values and having to propagate those changes elsewhere.
	public struct Point2D
	{
		public Point2D(int x, int y)
		{
			X = x;
			Y = y;
		}

		public Point2D(Vector2D vec)
		{
			X = vec.X;
			Y = vec.Y;
		}
		public Point2D(Vector2D vec, Point2D origin)
		{
			X = vec.X + origin.X;
			Y = vec.Y + origin.Y;
		}
		public Point2D(Position p)
		{
			X = p.Column;
			Y = p.Row;
		}

		public int X { get; }
		public int Y { get; }

		public override bool Equals(object obj)
		{
			if (obj is Point2D)
			{
				var p = (Point2D)obj;
				return p == this;
			}
			return base.Equals(obj);
		}

		public override string ToString() => $"[{X}, {Y}]";

		public override int GetHashCode() => 37 * Y + X;

		public static Point2D operator -(Point2D p) => new Point2D(-p.X, -p.Y);
		public static Point2D operator +(Point2D origin, Vector2D v) => new Point2D(origin.X + v.X, origin.Y + v.Y);
		public static Point2D operator +(Vector2D v, Point2D origin) => origin + v;
		public static Vector2D operator -(Point2D pA, Point2D pB) => new Vector2D(pA.X - pB.X, pA.Y - pB.Y);
		public static bool operator ==(Point2D pLhs, Point2D pRhs) => pLhs.X == pRhs.X && pLhs.Y == pRhs.Y;
		public static bool operator !=(Point2D pLhs, Point2D pRhs) => !(pLhs == pRhs);
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.Movement
{
	// This is a value type, meaning it is passed by value, not by reference.
	// Because it is a small value, this is generally a good thing.
	// It is immutable to avoid confusion when updating values and having to propagate those changes elsewhere.
	public struct Vector2D
	{
		public Vector2D(int x, int y)
		{
			X = x;
			Y = y;
		}

		public Vector2D(Point2D p)
		{
			X = p.X;
			Y = p.Y;
		}

		public int X { get; }
		public int Y { get; }

		public Vector2D FlipY() => new Vector2D(X, -Y);
		public Vector2D FlipX() => new Vector2D(-X, Y);

		/// <summary>
		/// Return the "Unit" Vector, where X and Y are simplified to -1, 0, or 1
		/// </summary>
		/// <returns>A new Vector2D</returns>
		public Vector2D GetUnitVector()
		{
			return new Vector2D(getUnitValue(X), getUnitValue(Y));
		}

		public override bool Equals(object obj)
		{
			if (obj is Vector2D)
			{
				var v = (Vector2D)obj;
				return v == this;
			}
			return base.Equals(obj);
		}

		public override string ToString() => $"[{X}, {Y}]";

		public override int GetHashCode() => 37 * Y + X;

		private static int getUnitValue(int num)
		{
			var unit = 0;
			if (num > 0)
			{
				unit = 1;
			}
			else if (num < 0)
			{
				unit = -1;
			}
			return unit;
		}

		public static Vector2D operator -(Vector2D vec) => new Vector2D(-vec.X, -vec.Y);
		public static Vector2D operator +(Vector2D vLhs, Vector2D vRhs) => new Vector2D(vLhs.X + vRhs.X, vLhs.Y + vRhs.Y);
		public static Vector2D operator -(Vector2D vLhs, Vector2D vRhs) => new Vector2D(vLhs.X - vRhs.X, vLhs.Y - vRhs.Y);
		public static bool operator ==(Vector2D vLhs, Vector2D vRhs) => vLhs.X == vRhs.X && vLhs.Y == vRhs.Y;
		public static bool operator !=(Vector2D vLhs, Vector2D vRhs) => !(vLhs == vRhs);
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.VoiceControl.Commands
{
	public class Command : ICommand
	{
		public CommandType Type { get; }
		
		public Command(CommandType type)
		{
			Type = type;
		}

		public Command(IReadOnlyDictionary<string, IReadOnlyList<string>> commandParams)
		{
			Type = CommandTypeMethods.Parse(commandParams);
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.VoiceControl.Commands
{
	public enum CommandFamily
	{
		Other,
		YesNo,
		Move,
		PieceConfirmation,
		Debug
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.VoiceControl.Commands
{
	public enum CommandType
	{
		Move,
		Reset,
		Undo,
		Yes,
		No,
		ConfirmPiece,
		Cancel,
		MotorMove,
		Magnet,
		Castle
	}

	public static class CommandTypeMethods
	{
		public static CommandFamily GetFamily(this CommandType type)
		{
			switch (type)
			{
				case CommandType.Move:
				case CommandType.Reset:
				case CommandType.Undo:
					return CommandFamily.Move;
				case CommandType.ConfirmPiece:
					return CommandFamily.PieceConfirmation;
				case CommandType.Yes:
				case CommandType.No:
					return CommandFamily.YesNo;
				case CommandType.MotorMove:
				case CommandType.Magnet:
					return CommandFamily.Debug;
				case CommandType.Castle:
				default:
					return CommandFamily.Other;
			}
		}
		public static CommandType Parse(IReadOnlyDictionary<string, IReadOnlyList<string>> commandParams)
		{
			IReadOnlyList<string> paramsList;
			if (commandParams.TryGetValue("action", out paramsList))
			{
				return Parse(paramsList.FirstOrDefault());
			}
			else
			{
				throw new ArgumentException($"Cannot create a Command without an action parameter. Received {commandParams.Count} parameters.");
			}
		}

		public static CommandType Parse(string actionStr)
		{
			switch (actionStr.ToLowerInvariant())
			{
				case "move":
					return CommandType.Move;
				case "reset":
					return CommandType.Reset;
				case "undo":
					return CommandType.Undo;
				case "yes":
					return CommandType.Yes;
				case "no":
					return CommandType.No;
				case "piececonfirmation":
					return CommandType.ConfirmPiece;
				case "cancel":
					return CommandType.Cancel;
				case "motormove":
					return CommandType.MotorMove;
				case "magnet":
					return CommandType.Magnet;
				case "castle":
					return CommandType.Castle;
				default:
					throw new ArgumentException($"Cannot convert string \"{actionStr}\" to an Action enum.");
			}
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Chess;

namespace WizardsChess.VoiceControl.Commands
{
	public class ConfirmPieceCommand : ICommand
	{
		public CommandType Type { get; }
		public PieceType? Piece { get; }
		public Position Position { get; }
		public bool PositionUsedNatoAlphabet { get; }

		public ConfirmPieceCommand()
		{
			Type = CommandType.ConfirmPiece;
		}

		public ConfirmPieceCommand(IReadOnlyDictionary<string, IReadOnlyList<string>> commandParams) : this()
		{
			IReadOnlyList<string> paramsList;
			if (commandParams.TryGetValue("piece", out paramsList))
			{
				Piece = PieceTypeMethods.Parse(paramsList.FirstOrDefault());
			}

			string posLetter = null;
			string posNumber = null;
			string posUsedNato = null;
			if (commandParams.TryGetValue("pieceLetter", out paramsList))
			{
				posLetter = paramsList.FirstOrDefault();
			}
			if (commandParams.TryGetValue("pieceNumber", out paramsList))
			{
				posNumber = paramsList.FirstOrDefault();
			}
			if (commandParams.TryGetValue("usedNato", out paramsList))
			{
				posUsedNato = paramsList.FirstOrDefault();
			}
			if (!String.IsNullOrWhiteSpace(posLetter) &&
				!String.IsNullOrWhiteSpace(posNumber) &&
				!String.IsNullOrWhiteSpace(posUsedNato))
			{
				Position = new Position(posLetter, posNumber);
				PositionUsedNatoAlphabet = posUsedNato.Equals("true", StringComparison.OrdinalIgnoreCase);
			}
			else
			{
				throw new ArgumentException($"Cannot create valid {nameof(ConfirmPieceCommand)} without a valid {nameof(Position)}");
			}
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.VoiceControl.Commands
{
	public interface ICommand
	{
		CommandType Type { get; }
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.VoiceControl.Commands
{
	public class MagnetCommand : Command
	{
		public bool EnableMagnet { get; }

		private MagnetCommand() : base(CommandType.Magnet) { }

		public MagnetCommand(ICommand command) : this()
		{
			var mCmd = command as MagnetCommand;
			if (mCmd != null)
			{
				EnableMagnet = mCmd.EnableMagnet;
			}
			else
			{
				System.Diagnostics.Debug.WriteLine("Attempted to make a new MagnetCommand from a different ICommand.");
				throw new InvalidCastException("Attempted to make a new MagnetCommand from a different ICommand.");
			}
		}

		public MagnetCommand(IReadOnlyDictionary<string, IReadOnlyList<string>> commandParams) : this()
		{
			IReadOnlyList<string> paramsList;

			if (Type == CommandType.Magnet)
			{
				if (commandParams.TryGetValue("enable", out paramsList))
				{
					EnableMagnet = Boolean.Parse(paramsList.FirstOrDefault());
				}
				else
				{
					System.Diagnostics.Debug.WriteLine("MagnetCommand did not receive an 'enable' value.");
				}
			}
			else
			{
				throw new ArgumentException("Attempted to make a MagnetCommand from a different command type.");
			}
		}
	}
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Chess;
using WizardsChess.Movement;

namespace WizardsChess.VoiceControl.Commands
{
	public class MotorMoveCommand : Command
	{
		public Axis Axis { get; }
		public int Steps { get; }

		private MotorMoveCommand() : base(CommandType.MotorMove) { }

		public MotorMoveCommand(ICommand command) : this()
		{
			var mvCmd = command as MotorMoveCommand;
			if (mvCmd != null)
			{
				Axis = mvCmd.Axis;
			}
			else
			{
				throw new InvalidCastException("Attempted to make a new MotorMoveCommand from a different ICommand.");
			}
		}

		public MotorMoveCommand(IReadOnlyDictionary<string, IReadOnlyList<string>> commandParams) : this()
		{
			IReadOnlyList<string> paramsList;

			if (Type == CommandType.MotorMove)
			{
				if (commandParams.TryGetValue("axis", out paramsList))
				{
					Axis = (Axis)Enum.Parse(typeof(Axis), paramsList.FirstOrDefault(), true);
				}
				else
				{
					System.Diagnostics.Debug.WriteLine("MotorMoveCommand did not receive an 'axis' value.");
				}
				if (commandParams.TryGetValue("steps", out paramsList))
				{
					int steps;
					if (!Int32.TryParse(paramsList.FirstOrDefault(), out steps))
					{
						System.Diagnostics.Debug.WriteLine("Could not parse steps for a motor move.");
					}
					else
					{
						Steps = steps;
					}
				}
				else
				{
					System.Diagnostics.Debug.WriteLine("MotorMoveCommand did not receive a 'steps' value.");
				}
				if (commandParams.TryGetValue("direction", out paramsList))
				{
					if (paramsList.FirstOrDefault().Equals("backward", StringComparison.OrdinalIgnoreCase))
					{
						Steps *= -1;
					}
				}
				else
				{
					System.Diagnostics.Debug.WriteLine("MotorMoveCommand did not receive a 'direction' value.");
				}
			}
			else
			{
				throw new ArgumentException("Attempted to make a MotorMoveCommand from a different command type.");
			}
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Chess;

namespace WizardsChess.VoiceControl.Commands
{
	public class MoveCommand : ICommand
	{
		public CommandType Type { get; }
		public PieceType? Piece { get; }
		public Position? Position { get; set; }
		public Position Destination { get; }
		public bool PositionUsedNatoAlphabet { get; }
		public bool DestinationUsedNatoAlphabet { get; }

		private MoveCommand()
		{
			Type = CommandType.Move;
		}

		public MoveCommand(ICommand command) : this()
		{
			var mvCmd = command as MoveCommand;
			if (mvCmd != null)
			{
				Piece = mvCmd.Piece;
				if (mvCmd.Position.HasValue)
				{
					Position = new Position(mvCmd.Position.Value);
					PositionUsedNatoAlphabet = mvCmd.PositionUsedNatoAlphabet;
				}
				Destination = new Position(mvCmd.Destination);
				DestinationUsedNatoAlphabet = mvCmd.DestinationUsedNatoAlphabet;
			}
		}

		public MoveCommand(IReadOnlyDictionary<string, IReadOnlyList<string>> commandParams) : this()
		{
			IReadOnlyList<string> paramsList;

			if (Type == CommandType.Move)
			{
				if (commandParams.TryGetValue("piece", out paramsList))
				{
					Piece = PieceTypeMethods.Parse(paramsList.FirstOrDefault());
				}
				var destLetter = commandParams["destinationLetter"].FirstOrDefault();
				var destNumber = commandParams["destinationNumber"].FirstOrDefault();
				Destination = new Position(destLetter, destNumber);
				var destUsedNato = commandParams["destinationUsedNato"].FirstOrDefault();
				DestinationUsedNatoAlphabet = destUsedNato.Equals("true", StringComparison.OrdinalIgnoreCase);
			}

			if (Type == CommandType.Move || Type == CommandType.ConfirmPiece)
			{
				string posLetter = null;
				string posNumber = null;
				string posUsedNato = null;
				if (commandParams.TryGetValue("positionLetter", out paramsList))
				{
					posLetter = paramsList.FirstOrDefault();
				}
				if (commandParams.TryGetValue("positionNumber", out paramsList))
				{
					posNumber = paramsList.FirstOrDefault();
				}
				if (commandParams.TryGetValue("positionUsedNato", out paramsList))
				{
					posUsedNato = paramsList.FirstOrDefault();
				}
				if (!String.IsNullOrWhiteSpace(posLetter) &&
					!String.IsNullOrWhiteSpace(posNumber) &&
					!String.IsNullOrWhiteSpace(posUsedNato))
				{
					Position = new Position(posLetter, posNumber);
					PositionUsedNatoAlphabet = posUsedNato.Equals("true", StringComparison.OrdinalIgnoreCase);
				}
			}
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.VoiceControl.Commands;

namespace WizardsChess.VoiceControl.Events
{
	public class CommandEventArgs : EventArgs
	{
		public ICommand Command { get; }

		public CommandEventArgs(ICommand command) : base()
		{
			Command = command;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.VoiceControl.Commands;

namespace WizardsChess.VoiceControl.Events
{
	public class CommandHypothesisEventArgs : CommandEventArgs
	{
		public string CommandText { get; }

		public CommandHypothesisEventArgs(ICommand command, string commandText) : base(command)
		{
			CommandText = commandText;
		}
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.Chess;
using WizardsChess.VoiceControl.Commands;

namespace WizardsChess.VoiceControl
{
	public interface ICommandInterpreter
	{
		event CommandEventHandler CommandReceived;

		Task StartAsync();
		Task ConfirmPieceSelectionAsync(PieceType pieceType, IReadOnlyList<Position> possiblePositions);
	}
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using WizardsChess.VoiceControl.Commands;
using WizardsChess.VoiceControl.Events;

namespace WizardsChess.VoiceControl
{
	public interface ICommandListener
	{
		bool IsListening { get; }

		Task StartListeningAsync();
		Task StopListeningAsync();

		event CommandEventHandler ReceivedCommand;
		event CommandHypothesisEventHandler ReceivedCommandHypothesis;
	}

	public delegate void CommandEventHandler(Object sender, CommandEventArgs e);
	public delegate void CommandHypothesisEventHandler(Object sender, CommandHypothesisEventArgs e);
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WizardsChess.VoiceControl
{
	public interface ICommunicator
	{
		Task SpeakAsync(string text);
	}
}
